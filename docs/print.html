<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">2.</strong> Entities</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">3.</strong> Aggregates</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">4.</strong> Events</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">5.</strong> Commands</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">6.</strong> Application Layer</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">7.</strong> Repository</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">8.</strong> Storage</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">9.</strong> Refactoring</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">10.</strong> Testing</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">11.</strong> Apache Kafka</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/tonyx/Micro_ES_FSharp_Lib">Sharpino</a> is a little F# event sourcing framework.
With Sharpino you can build an event sourced application using a functional approach. 
Two types of event sourced objects are supported: <em>Contexts</em> and <em>Aggregates</em>.
<em>Contexts</em>: There is no specific id for a context so we just assume that a single instance and a single zero (initial state) instance exist for any <em>Context</em>.
<em>Aggregates</em>: Many instances of an aggregate can exist at a time so we need an Id for each instance represented by a Guid. The initial state for any aggregate is its initial snapshot in the event store.</p>
<p>Contexts and aggregates will implement transformation members that will return a new object with a new state using the Result data type. We tipically use Railway oriented programming is used to handle errors in any transformation operation (by the FsTookit.ErrorHandling library).</p>
<p>We associate transformation members with events: processing an event will return a new object with a new state by invoking the transformation member associated with the event.
Commands are function that given a state of a context/aggregate and some parameters will return a pari of a new state of the context/aggregate and the list of the events that, processed, will return such state. </p>
<p>Commands and events can be easily implemented using Discriminated Union types implementing the <em>Command</em> and the <em>Event</em> interfaces respectively.</p>
<p>This document is a guide to the Sharpino library. It is a work in progress.
Focus on the following topics:
Contexts, events, commands, service application layer, Event Store.</p>
<h2 id="the-sample-application-1"><a class="header" href="#the-sample-application-1">The sample application 1.</a></h2>
<p>This application will be deprecated as it fails in showing the main features of the library.</p>
<h2 id="sample-application-2-booking-system-for-seats-in-a-stadium"><a class="header" href="#sample-application-2-booking-system-for-seats-in-a-stadium">Sample application 2. Booking system for seats in a stadium</a></h2>
<p>Contexts represent rows. Some constraints are applied to the rows. The context is responsible for the seats. The seats are associated with the rows.</p>
<h2 id="sample-application-3-booking-system-for-seats-in-a-stadium"><a class="header" href="#sample-application-3-booking-system-for-seats-in-a-stadium">Sample application 3. Booking system for seats in a stadium</a></h2>
<p>The same as application 2 but where rows are aggregates (so I can have any number of instances of seat rows). The application uses the SAFE based stack based template son can publish the system as a rest service using the Fable Remoting library.</p>
<h2 id="sample-application-6-pub-system"><a class="header" href="#sample-application-6-pub-system">Sample application 6. Pub system</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>I am representing in this example the Todo entity and a Todo context</p>
<p>This is the Todo entity definition:</p>
<pre><code class="language-FSharp">    type Todo =
        {
            Id: Guid
            CategoryIds : List&lt;Guid&gt;
            TagIds: List&lt;Guid&gt;
            Description: string
        }
    type Todos =
        {
            todos: List&lt;Todo&gt;
        }
        with
            static member Zero =
                {
                    todos = []
                }
</code></pre>
<p>The Todos context needs also some other members (to handle the stream name, the serialize/deserialize functions, and the snapshots interval...)</p>
<p>The Context will define a <em>Zero</em> static member (initial state).
In case we use 
<a href="https://github.com/Zaid-Ajaj/Fable.Remoting">Fable remoting</a>)
then we need to share the definition of the entities between the client and the server side.
(Shared project)</p>
<p>Source: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample.Shared/Entities.fs">TodosModel.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context-1"><a class="header" href="#context-1">Context</a></h1>
<p>A context is a class meant to be event-sourced, i.e. associated with a stream of events.
To buld the state of a context using stored events we use the <em>evolve</em> function.</p>
<p><em>events</em> are associated to members of the cluster that end up in Update/Delete/Remove of some entity</p>
<p>Static members that are mandatory for any cluster of entities are:</p>
<ul>
<li>
<p><strong>Zero</strong>: the initial state (no events yet).</p>
</li>
<li>
<p><strong>StorageName</strong> and  <strong>Version</strong>: this combination uniquely identifies the cluster and lets the storage know in which stream to store events and snapshots. Whatever will be the storage (memory, Postgres, EventstoreDb, etc.) the cluster will be stored in a stream named as the concatenation of the <em>StorageName</em> and the <em>Version</em> (i.e. &quot;_todo_01&quot;)</p>
</li>
<li>
<p><strong>SnapshotsInterval</strong>: the number of events that can be stored after a snapshot before creating a new snapshot (i.e. the number of events between snapshots).</p>
</li>
</ul>
<p>The Command handler, by the runCommand function, applies a command, then stores the related events and returns the EventStore (database) IDs of those stored events and the KafkaDeliveryResult (if Kafka broker is enabled).</p>
<p>Example of a cluster of entities handling the todos and the categories:</p>
<pre><code class="language-FSharp">    type Todos =
        {
            todos: Todos
            categories: Categories
        }
        static member Zero =
            {
                todos = Todos.Zero
                categories = Categories.Zero
            }
        static member StorageName =
            &quot;_todo&quot;
        static member Version =
            &quot;_01&quot;
        static member SnapshotsInterval =
            15
        static member Deserialize (s: string) =
            jsonSerializer.Deserialize&lt;Todos&gt; s
        member Serialize = 
            this
            |&gt; jsonSerializer.Serialize
</code></pre>
<p>In the following example, the TodosContext can check the validity of the categories referenced by any todo before adding it (to preserve the invariant rule that you can add only todo with valid category ID references).
It uses the &quot;result&quot; computational expression included in the FsToolkit.ErrorHandling library which supports the <a href="https://fsharpforfunandprofit.com/rop/"><em>railway-oriented programming</em></a> pattern of handling errors.</p>
<p>Example:</p>
<pre><code class="language-FSharp">    member this.AddTodo (t: Todo) =
        let checkCategoryExists (c: Guid ) =
            this.categories.GetCategories() 
            |&gt; List.exists (fun x -&gt; x.Id = c) 
            |&gt; boolToResult (sprintf &quot;A category with id '%A' does not exist&quot; c)

        result
            {
                let! categoriesMustExist = t.CategoryIds |&gt; catchErrors checkCategoryExists
                let! todos = this.todos.AddTodo t
                return 
                    {
                        this with
                            todos = todos
                    }
            }
</code></pre>
<p>Todo: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/Domain/Todos/Context.fs">Context.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>Events are discriminated unions (DU) with cases associated with transformation members.</p>
<p>When we process an event it returns a new state or an error: </p>
<pre><code class="language-FSharp">    type Event&lt;'A&gt; =
        abstract member Process: 'A -&gt; Result&lt;'A, string&gt;
</code></pre>
<p>The <em>'A</em> is the generic context or aggregate type, the event is associated with.</p>
<p>This is an example of a concrete implementation of an event related to the TodoCluster members <em>Add</em> and <em>Remove</em>.</p>
<p>So, for example, the <em>TodoAdded</em> event is associated with the <em>AddTodo</em> member.
The <em>Process</em> member of the event is implemented by calling the related clusters member.</p>
<pre><code class="language-Fsharp">    type TodoEvent =
        | TodoAdded of Todo
        | TodoRemoved of Guid
            interface Event&lt;TodosCluster&gt; with
                member this.Process (x: TodosContext ) =
                    match this with
                    | TodoAdded (t: Todo) -&gt; 
                        x.AddTodo t
                    | TodoRemoved (g: Guid) -&gt; 
                        x.RemoveTodo g

</code></pre>
<p>Source code:  <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/Domain/Todos/Events.fs">Events.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>(this section needs an update as we have a new )</p>
<p>A Command type is a Discriminated Union. Executing the command on a specific context or aggregate means returning a new state and, accordingly, a list of events, or an error.
You can also specify <em>&quot;command undoers&quot;</em>, that allow you to compensate the effect of a command. An undoer returns a new function that in the future can be executed to return the events that can reverse the effect of the command itself.
For example, the &quot;under&quot; of AddTodo is the related RemoveTodo (see next paragraph).</p>
<p>In the following code we can see the signature for any state viewers for any context or aggregate. State viewer corresponds to read models: they will provide the current state of aggregate or context. Typically, that state may come from a cache, from the event store (by processing the events) or from a topic of Kafa (or eventually any other message/event broker, even though I haven't implemented completed any of them yet).</p>
<pre><code class="language-FSharp">
    type StateViewer&lt;'A&gt; = unit -&gt; Result&lt;EventId * 'A, string&gt;
    type AggregateViewer&lt;'A&gt; = Guid -&gt; Result&lt;EventId * 'A,string&gt;
    
    type Aggregate&lt;'F&gt; =
        abstract member Id: Guid // use this one to be able to filter related events from same string
        abstract member Serialize: 'F
    
    type Event&lt;'A&gt; =
        abstract member Process: 'A -&gt; Result&lt;'A, string&gt;

    type Command&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;'A * List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; StateViewer&lt;'A&gt; -&gt; Result&lt;unit -&gt; Result&lt;List&lt;'E&gt;, string&gt;, string&gt;&gt;
        
    type AggregateCommand&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;'A * List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; AggregateViewer&lt;'A&gt; -&gt; Result&lt;unit -&gt; Result&lt;List&lt;'E&gt;, string&gt;, string&gt;&gt;


</code></pre>
<p>Example:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        | AddTodo of Todo
        | RemoveTodo of Guid

        interface Command&lt;TodosContext, TodoEvent&gt; with
            member this.Execute (x: TodosContext) =
                match this with
                | AddTodo t -&gt; 
                    match x.AddTodo t with
                    | Ok _ -&gt; [TodoAdded] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
                | RemoveTodo g -&gt;
                    match
                        x.RemoveTodo g with
                        | Ok _ -&gt; [TodoEvent.TodoRemoved g] |&gt; Ok
                        | Error x -&gt; x |&gt; Error
            member this.Undoer = None
</code></pre>
<p>A command may return more than one event:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        [...]
        | Add2Todos of Todo * Todo
        interface Command&lt;TodosCluster, TodoEvent&gt; with
            member this.Execute (x: TodosContext) =
            [...]
            match this with
            | Add2Todos (t1, t2) -&gt; 
                let evolved =
                    fun () -&gt;
                    [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2]
                    |&gt; evolveUNforgivingErrors x
                match evolved() with
                    | Ok _ -&gt; [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
            member this.Undoer

</code></pre>
<p>Any command must ensure that it will return Result.OK (and therefore, one or more events) only if the events to be returned, when processed on the current state, return an Ok result, i.e. a valid state (and no error). </p>
<p>There are two version of the <em>evolve</em>: one tolerates inconsistent events and another one will fail in case just an event will return an error.
The way the evens are stored in the event store ensures that no stored event will return inconsistent state when processed. Therefore future releases of the library will probably use by default the unforgiving version of the <em>evolve</em> function.</p>
<h2 id="undoer"><a class="header" href="#undoer">Undoer</a></h2>
<p>Here is an example of the use of an undoer for a command:</p>
<pre><code class="language-fsharp">module CartCommands =
    type CartCommands =
    | AddGood of Guid * int
    | RemoveGood of Guid
        interface AggregateCommand&lt;Cart, CartEvents&gt; with
            member this.Execute (cart: Cart) =
                match this with
                | AddGood (goodRef, quantity) -&gt; 
                    cart.AddGood (goodRef, quantity)
                    |&gt; Result.map (fun s -&gt; (s, [GoodAdded (goodRef, quantity)]))
                | RemoveGood goodRef -&gt;
                    cart.RemoveGood goodRef
                    |&gt; Result.map (fun s -&gt; (s, [GoodRemoved goodRef]))
            member this.Undoer = 
                match this with
                | AddGood (goodRef, _) -&gt; 
                    Some 
                        (fun (cart: Cart) (viewer: AggregateViewer&lt;Cart&gt;) -&gt;
                            result {
                                let! (i, _) = viewer (cart.Id) 
                                return
                                    fun () -&gt;
                                        result {
                                            let! (j, state) = viewer (cart.Id)
                                            let! isGreater = 
                                                (j &gt;= i)
                                                |&gt; Result.ofBool (sprintf &quot;execution undo state '%d' must be after the undo command state '%d'&quot; j i)
                                            let result =
                                                state.RemoveGood goodRef
                                                |&gt; Result.map (fun _ -&gt; [GoodRemoved goodRef])
                                            return! result
                                        }
                                }
                        )
                | RemoveGood goodRef -&gt;
                    Some
                        (fun (cart: Cart) (viewer: AggregateViewer&lt;Cart&gt;) -&gt;
                            result {
                                let! (i, state) = viewer (cart.Id) 
                                let! goodQuantity = state.GetGoodAndQuantity goodRef
                                return
                                    fun () -&gt;
                                        result {
                                            let! (j, state) = viewer (cart.Id)
                                            let! isGreater = 
                                                // this check depends also on the number of events generated by the command (i.e. the j &gt;= (i+1) if command generates 2 event)
                                                (j &gt;= i)
                                                |&gt; Result.ofBool (sprintf &quot;execution undo state '%d' must be after the undo command state '%d'&quot; j i)
                                            let result =
                                                state.AddGood (goodRef, goodQuantity)
                                                |&gt; Result.map (fun _ -&gt; [GoodAdded (goodRef, goodQuantity)])
                                            return! result
                                        }
                                }
                        )
</code></pre>
<p>This is the abstract definition of an of the undoer of an aggregate.</p>
<pre><code class="language-FSharp">        abstract member Undoer: Option&lt;'A -&gt; AggregateViewer&lt;'A&gt; -&gt; Result&lt;unit -&gt; Result&lt;List&lt;'E&gt;, string&gt;, string&gt;&gt;
</code></pre>
<p>The meaning is:
Extract from the current state of the aggregate useful info for a future &quot;rollback&quot;/&quot;undo&quot; and return a function that, when applied to the current state of the aggregate, will return the events that will &quot;undo&quot; the effect of this command.</p>
<p>You may need undoers if the event store doesn't support multiple stream transactions or if you will use a distributed architecture with many nodes handling different streams of events.
By using PostgresSQL as event store you can just set the undoer to None as the event store will handle the cross-streams transactions for us. </p>
<p><a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/Domain/Tags/Commands.fs">Commands.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-service-layer"><a class="header" href="#application-service-layer">Application service layer</a></h1>
<p>An application service layer implements the logic to the outside world.
Here is one of the simplest examples of an entry for a service involving a single context, by building and running an AddTag command.</p>
<pre><code class="language-FSharp">        member this.AddTag tag =
            result {
                let! result =
                    tag
                    |&gt; AddTag
                return result 
            }
</code></pre>
<p>The service layer sends commands to the Command Handler so that this one can run it producing and storing the related events, returning the EventStore Ids of the stored events.</p>
<h2 id="running-two-commands-to-different-clusters"><a class="header" href="#running-two-commands-to-different-clusters">Running two commands to different clusters</a></h2>
<p>This code removes the tag with any reference to it. It builds two commands and makes the repository process them at the same time.
This code removes a tag and any reference to it.</p>
<pre><code class="language-FSharp">    member this.removeTag id =
        ResultCE.result {
            let removeTag = TagCommand.RemoveTag id
            let removeTagRef = TodoCommand.RemoveTagRef id
            return! runTwoCommands&lt;Tag, Todo, TagEvent, TodoEvent&gt; eventStore eventBroker removeTag removeTagRef
        }
</code></pre>
<p>Source: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/App.fs">App.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-handler"><a class="header" href="#command-handler">Command Handler</a></h1>
<p>The Command Handler has the responsibility of:</p>
<ul>
<li>getting the state</li>
<li>trying to run commands passed, and eventually storing the related events.</li>
<li>making periodic snapshots, according to the SnapshotsInterval.</li>
</ul>
<p>There are two different command handler implementations:</p>
<p><a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/CommandHandler.fs">CommandHandler.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eventstore-database"><a class="header" href="#eventstore-database">EventStore (database)</a></h1>
<p>An event-store, stores and retrieves events and snapshots related to each single context.</p>
<p>An example of a storage implementation in Postgres: 
<a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/PgEventStore.fs">PgEventStore.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactoring-aggregates"><a class="header" href="#refactoring-aggregates">Refactoring Aggregates</a></h1>
<p>If you need to change an aggregate (or context) for new requirements we need to refactor the aggregate.</p>
<p>The technique is based on being able to create an aggregate that mimics the old one and an upcast function from the old one to the new one.</p>
<p>Beside this, you may do a bulk upcast of all the existing aggregates by making a snapthot of all of them.
The new snapthot will use the new aggregate format so the definition of the old aggregate will be unnecessary after the bulk upcast and resnapshot.</p>
<p>You will create the shadow aggregate that mimic the old one in the same module of the current one, providing that the module is defined as rec. </p>
<p>The mechanism is based on handling the failure of the Deserialization by using as fallback the Deserialization using the old aggregate and then the upcast function to the new one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>As I mentioned in the previous chapter we may have different versions of the same application based on different clusters.</p>
<p>We may want to test all of them and also we may want to test the migration function from one version to another in those tests.
A structure of a parametric test that considers various possible combinations of application versions and migration functions is the following:</p>
<pre><code class="language-FSharp">
        multipleTestCase &quot;test something &quot; versions &lt;| fun (ap, apUpgd, migrator)  -&gt;
            let _ = ap._reset()

            // test something on ap, which is the &quot;initial version&quot; 
            // of the application
            .....

            // then migrate from &quot;ap&quot; version to apUpgd version 
            // using its migrator function

            let migrated = migrator()
            Expect.isOk migrated &quot;should be ok&quot;

            // test something on apUpgd, which is the &quot;upgraded version&quot; of the application

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-kafka"><a class="header" href="#apache-kafka">Apache Kafka</a></h1>
<p>We will see later if and when an event broker is needed.</p>
<p>Anyway the mechanism should be: after the event is stored in the event store, it will be published to a queue/topic/message bus.</p>
<p>The command handler will still use the event store to get the state of the context and to store the events.</p>
<p>An application layer may read the state of some aggregate/context by listening the events.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
