<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">2.</strong> Models</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">3.</strong> Aggregates</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">4.</strong> Events</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">5.</strong> Commands</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">6.</strong> Application Layer</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">7.</strong> Repository</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">8.</strong> Storage</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">9.</strong> Refactoring</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/tonyx/Micro_ES_FSharp_Lib">Sharpino</a> is a simple F# event sourcing framework.
It is a project for study and for experimenting.
At the moment (2023-08-06) it supports <em>in memory</em> and <em>postgres</em> storages.
There is also an experimental support for eventstoredb.</p>
<p>Here I am giving a quick overview to how it works, how the sample application works (from models to application service layer and without any user interface) and how to handle aggregate refactoring.</p>
<h2 id="the-sample-application"><a class="header" href="#the-sample-application">The sample application</a></h2>
<p>The sample application is a simple todo list manager where each todo contains reference to Tags and Categories.
There are two version of the same application that use different aggregate configurations.</p>
<p>The &quot;version 1&quot; has an Aggregate managing Todo and Categories, and another aggregate managing Tags.</p>
<p>The &quot;version 2&quot; of the application consists in three different aggregates: one for the Todo model, one for the Categories model, and another one for the Tags model.</p>
<p>The challenge is that you can write parametric tests that can be executed against the current and the next aggregate configuration, also by testing the migration function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="models"><a class="header" href="#models">Models</a></h1>
<p>In Sharpino the models are collections of entities.
The general case is that a model contains has no direct reference to any other model but may reference them by their id. So for instance a todo may contain a list of tag ids and a list of category ids.
This is the general case because it is the most flexible one: you can change the model without any need to change the other models
However there can be exceptions for models that are are closely related: for instance you may rather define a model for orders and a model for orderitems in the same place, so that any orders can contain direct reference to orderitems instead of id of orderitems.</p>
<p>Here there is a simple model of the todo items:</p>
<pre><code class="language-FSharp">    type Todo =
        {
            Id: Guid
            CategoryIds : List&lt;Guid&gt;
            TagIds: List&lt;Guid&gt;
            Description: string
        }
    type Todos =
        {
            todos: List&lt;Todo&gt;
        }
        with
            static member Zero =
                {
                    todos = []
                }
</code></pre>
<p>You've seen a special &quot;Zero&quot; static member. The aggregate will use it to define its own <em>Zero</em> static member that is mandatory for any aggregate.
The <em>Zero</em> static member is the initial state of the aggregate and it is used to rebuild the state of the aggregate when there are no events stored for that aggregate.
Note that in some popular full stack development FSharp technologies some definitions must stay in a separate project shared beteen the client and the server separate projects.
In that case we would define the &quot;Todo&quot;, the &quot;Tag&quot; and the &quot;Category&quot; types in a shared project.
(See Fable remoting for more informations about that).</p>
<p>Source: <a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Sample/models/TodosModel.fs">TodosModel.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregates"><a class="header" href="#aggregates">Aggregates</a></h1>
<p>An aggregate is an instance of a class (or more properly, a record) that handles one or more models. We will be able to recreate the state of the aggregate by processing the stored events by an essential function called <em>evolve</em>. Such   <em>events</em> are closely related to some of the members of the aggregate. </p>
<p>Given that the state of the aggregatre is a function of the related events processed and stored, an aggregate needs the following information associated that I defined as mandatory, static members:</p>
<ul>
<li>
<p><strong>Zero</strong>: the instance of the aggregate in its intitial state. 
It is needed to be able to provide the state of the aggregate when there is no event stored related to that aggregate.</p>
</li>
<li>
<p><strong>StorageName</strong> and  <strong>Version</strong>: this combination uniquely identifies the aggragate and lets the storage know in which stream to store events and snapshots.</p>
</li>
<li>
<ul>
<li><strong>LockObject</strong>: (<em>warning: the lockobject concept is obsolete. It was meant to handle single thread processing but at the moment I am providing an actor model based mailboxprocessor to ensure single thread chain command-&gt;events-&gt;eventstoring, so you will skip this part</em>). Before introducing the <em>mailboxprocessor</em> (i.e. an actor model based single thread message processor), the repository was supposed to use aggregate locks while processing command and storing related events ensuring consistency. An application layer was also supposed to use them explicitly to ensure inter-aggregate integrity (invariant conditions involving models handled by separate aggregates).</li>
</ul>
</li>
<li>
<p><strong>SnapshotsInterval</strong>: the number of the events that can be stored after a snapshot before creating a new snapshot (i.e. the numer of events between snapshots)</p>
</li>
</ul>
<p>Note that in the <em>in memory</em> or <em>Postgres</em> storage implementation the state of any aggregate is rebuilt starting from the last available snapshot and applying the events that are after the snapshot.
At the moment I have no specific strategy for hadling snapshots and interval between snapshots for the EventStoreDb. </p>
<p>Example:</p>
<pre><code class="language-FSharp">    type TodosAggregate =
        {
            todos: Todos
            categories: Categories
        }
        static member Zero =
            {
                todos = Todos.Zero
                categories = Categories.Zero
            }
        static member StorageName =
            &quot;_todo&quot;
        static member Version =
            &quot;_01&quot;
        static member SnapshotsInterval =
            15
</code></pre>
<p>Some members of the aggregate virtually change the state of the aggregate in the sense that they return an instance of the aggregate in a different state or an error. It atually means that such members will do <em>add/upate/delete</em> to some of their models (still in a functional/immutable way i.e. returning the model with changes). Those members will be associated to aggregate <em>events</em> (see next section).
In the following example the aggregate of the Todos manages also the categories model and so it can check the validity of the categories referenced by a todo before adding it (to preserve the rule that you can add only todo with categoryIds related to existing categories).
It uses the &quot;result&quot; computational expression included in the FsToolkit.ErrorHandling library supporting the possibility to handle errors in a <em>railway oriented programming</em> style.</p>
<p>Example:</p>
<pre><code class="language-FSharp">    member this.AddTodo (t: Todo) =
        let checkCategoryExists (c: Guid ) =
            this.categories.GetCategories() 
            |&gt; List.exists (fun x -&gt; x.Id = c) 
            |&gt; boolToResult (sprintf &quot;A category with id '%A' does not exist&quot; c)

        result
            {
                let! categoriesMustExist = t.CategoryIds |&gt; catchErrors checkCategoryExists
                let! todos = this.todos.AddTodo t
                return 
                    {
                        this with
                            todos = todos
                    }
            }
</code></pre>
<p>Recap: we can protect invariant conditions related to models that are part of the same aggregate without the need of any explicit transaction, because at that level there is no awareness of the storage. Still, we can protect other invariant conditions that may involve models residing in different aggregates anyway in a different way:  at the service application layer (see in next sections).</p>
<p>Source: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/aggregates/Todos/Aggregate.fs">TodosAggregate.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>As I said before, some members of an aggregate act as &quot;state changer&quot;, operating add/update/delete on one or more of its models. 
Each aggregate has an associated Event type and such event type is a Discriminated Union (Du) type with a case associated to &quot;state changer&quot; members of the aggregate.</p>
<p>An event type can be defined, in abstract, as something that, when processed, return a new state of the aggregate or an error, which fits the following definition:</p>
<pre><code class="language-FSharp">    type Event&lt;'A&gt; =
        abstract member Process: 'A -&gt; Result&lt;'A, string&gt;
</code></pre>
<p>The <em>'A</em> is the generic aggregate type the event is associated to.</p>
<p>This is an example of a concrete implementation ov event relate to the TodoAggregate members <em>Add</em> and <em>Remove</em>:</p>
<pre><code class="language-Fsharp">    type TodoEvent =
        | TodoAdded of Todo
        | TodoRemoved of Guid
            interface Event&lt;TodosAggregate&gt; with
                member this.Process (x: TodosAggregate ) =
                    match this with
                    | TodoAdded (t: Todo) -&gt; 
                        x.AddTodo t
                    | TodoRemoved (g: Guid) -&gt; 
                        x.RemoveTodo g

</code></pre>
<p>This shows that processing an event means calling the related aggregate member.</p>
<p>You can do event caching by wrapping the call to the specific aggregate member in a lambda expression without evaluating it, and passing it to a specific cache manager that may eventually evaluate it and return the result or the cached result if the event has already been processed.</p>
<pre><code class="language-Fsharp">    type TodoEvent =
        | TodoAdded of Todo
        | TodoRemoved of Guid
            interface Event&lt;TodosAggregate&gt; with
                member this.Process (x: TodosAggregate ) =
                    match this with
                    | TodoAdded (t: Todo) -&gt; 
                        EventCache&lt;TodosAggregate&gt;.Instance.Memoize (fun () -&gt; x.AddTodo t) (x, [TodoAdded t]) 
                    | TodoRemoved (g: Guid) -&gt; 
                        EventCache&lt;TodosAggregate&gt;.Instance.Memoize (fun () -&gt; x.RemoveTodo g) (x, [TodoRemoved t]) 
</code></pre>
<p>Having said that about caching, I am warning that  caching events doesn't look so much a &quot;performance booster&quot;. It looks more promising the caching of the state of the aggregate (see the next section).</p>
<p>Therefore event Caching is disabled by default. See &quot;EVENTS_CACHING_ENABLED&quot; in the project file: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/Sharpino.Lib.fsproj">project file</a>
To enabled the caching of events, the library must be compiled with the following compilation symbol: <code>EVENTS_CACHING_ENABLED</code>.</p>
<p>Source:  <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/aggregates/Todos/Events.fs">Events.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>We define a command type for each aggregate.
A Command type is a Discriminated Union. Executing the command means returning a lists of events or an error.
We have also <em>&quot;command undoers&quot;</em>, that allow us to compensate the effect of a command in case it is part of a multiple stream transaction that fails  as we will see later.</p>
<p>The abstract definitions of Command and Undoer  are:</p>
<pre><code class="language-FSharp">
    type Undoer&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; = 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;

    type Command&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; Result&lt;Undoer&lt;'A, 'E&gt;, string&gt;&gt;

</code></pre>
<p>Example:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        | AddTodo of Todo
        | RemoveTodo of Guid

        interface Command&lt;TodosAggregate, TodoEvent&gt; with
            member this.Execute (x: TodosAggregate) =
                match this with
                | AddTodo t -&gt; 
                    match x.AddTodo t with
                    | Ok _ -&gt; [TodoAdded] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
                | RemoveTodo g -&gt;
                    match
                        x.RemoveTodo g with
                        | Ok _ -&gt; [TodoEvent.TodoRemoved g] |&gt; Ok
                        | Error x -&gt; x |&gt; Error
            member this.Undoer = None
</code></pre>
<p>It is possible, althought uncommon, to have, for a command, cases that can return multiple events as follows:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        [...]
        | Add2Todos of Todo * Todo
        interface Command&lt;TodosAggregate, TodoEvent&gt; with
            member this.Execute (x: TodosAggregate) =
            [...]
            match this with
            | Add2Todos (t1, t2) -&gt; 
                let evolved =
                    fun () -&gt;
                    [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2]
                    |&gt; evolveUNforgivingErrors x
                match evolved() with
                    | Ok _ -&gt; [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
            member this.Undoer

</code></pre>
<p>It is important that any command must ensure that it will return Ok (and therefore, one or more events) only if when those events to be returned, when processed with the current aggregate state, give an Ok result, i.e. a valid aggregate state (and no error). 
For that reason, before returning the events, I invoked the &quot;evolveUNforgivingErrors&quot; function to &quot;probe&quot; the sequence of two events to be eventually returned. 
The evolveUNforgivingErrors processes some events to a given state of the aggregate returning an error or a valid state.
There is also a similar function <em>evolve</em> which is more tollerant and will just skip events that, when processed gives error, and can return a valid aggregate state anyway. </p>
<p>Commands can use event caching if it is enabled as we have seen in the previous section.</p>
<h2 id="undoer"><a class="header" href="#undoer">Undoer</a></h2>
<p>A command case in a command type definition may have associated an <em>undoer</em> which is similar to a command itself, but it is aimed to eventually do the &quot;reverse&quot; of a command, which means  compensating the effect of a command in case such command is a part of a multiple stream transaction that fails. We need the <em>undoer</em> only if the storage lack of multiple streams transactions (which is the case of EventStoreDb)</p>
<pre><code class="language-FSharp">    type Undoer&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; = 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;
</code></pre>
<p>So, as a recap: when the repository uses storages like <em>in memory</em> or <em>Postgres</em>, it doesn't need any <em>undoer</em> because those storages support multiple stream transactions.
If you will use an EventStoreDb like engine as storage, you may want to provide an undoer for each command case.</p>
<p>I am going to show an example of an undoer. Let me remind the abstract definition of a command.</p>
<pre><code class="language-FSharp">    type Command&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; Result&lt;Undoer&lt;'A, 'E&gt;, string&gt;&gt;
</code></pre>
<p>Given the current state of the aggregate, the &quot;command undoer&quot; returns a function that, applied to the aggregate state, must return the actual undoer.</p>
<p>So the undoers works in two shots: one to build a context for the eventual future undo, and one to atually... <em>do</em> the <em>undo!</em>. </p>
<p><strong>A Concrete example</strong>:</p>
<p>The removeTag command returns a list of TagRemoved events. We know that when those events are processed the result is the aggregate without the tags.
However we may want to rollback the effect of those events by adding events that reverse thir effect.</p>
<p>This applies to a transaction context: you need to be able to readd the tag to the aggregate state. For this reason you need to build a context  <em>before</em> the removal so that the tag to be eventually readded is still available.</p>
<p>From the code with some comments:</p>
<pre><code class="language-Fsharp">    member this.Undoer = 
        match this with
        | RemoveTag g -&gt; 
            // block to be executed before the actual command removing tag is executed. It will return another function with the context needed (the tag itself)
            (fun (x: TagsAggregate) -&gt;
                result {
                    let! tag = x.GetTag g
                    let result =

                        // block to be executed after the actual command removing tag is executed. It will return the list of events to be applied to the aggregate state to compensate the effect of the command. Note that the tag is the context needed to readd the tag to the aggregate state.

                        fun (x': TagsAggregate) -&gt;
                            x'.AddTag tag 
                            |&gt; Result.map (fun _ -&gt; [TagAdded tag])
                    return result
                }
            )
            |&gt; Some
        | AddTag t -&gt;
            // this case is simple than the previous because there is no need to retrieve anything from the context before the command is executed. The context is the tag itself (particularly its id), that can't be lost during the transaction.
            (fun (_: TagsAggregate) -&gt;
                fun (x': TagsAggregate) -&gt;
                    x'.RemoveTag t.Id 
                    |&gt; Result.map (fun _ -&gt; [TagAdded t])
                |&gt; Ok
            )
            |&gt; Some

</code></pre>
<p>Sources: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/aggregates/Todos/Commands.fs">Commands.fs</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-service-layer"><a class="header" href="#application-service-layer">Application service layer</a></h1>
<p>An application service layer provides services that actually use Respository and Storage to get the state and/or send commands to one or more aggregates (eventually in an atomic/transactional way with potential issues already discussed).</p>
<p>Here is one of the simplest example of an entry for a services involving a single aggregate, by builing and running a AddTag command.</p>
<pre><code class="language-FSharp">    member this.addTag tag =
        result {
            let! _ =
                tag
                |&gt; AddTag
                |&gt; (runCommand&lt;TagsAggregate, TagEvent&gt; storage)
            return ()
        }
</code></pre>
<p>The service layer sends commands to the repository so that this one can run it producing and storing the related events.</p>
<p>The following example shows a service layer that uses two aggregates and an explicit lock (note that the lock object concept to handle transaction has been substituted by a mailboxprocessor based actor model. Still I'm not sure if the lock object approach deserved to be dismissed).</p>
<p>I will show an example involving the new version right after this one.</p>
<pre><code class="language-FSharp">    member this.addTodo todo =
        lock TagsAggregate.LockObj &lt;| fun () -&gt;
            ResultCE.result {
                let! (_, tagState) = getState&lt;TagsAggregate, TagEvent&gt;(storage)
                let tagIds = tagState.GetTags() |&gt;&gt; (fun x -&gt; x.Id)

                let! tagIdIsValid =    
                    (todo.TagIds.IsEmpty ||
                    todo.TagIds |&gt; List.forall (fun x -&gt; (tagIds |&gt; List.contains x)))
                    |&gt; boolToResult &quot;A tag reference contained is in the todo is related to a tag that does not exist&quot;

                let! _ =
                    todo
                    |&gt; TodoCommand.AddTodo
                    |&gt; (runCommand&lt;TodosAggregate, TodoEvent&gt; storage)
            return ()
        }
</code></pre>
<p>The todo can be added only if it contains valid tag references.</p>
<p>Now I am showing how I decided to deal with the same issue of making the code safe  (transactional) by using the mailboxprocessor, part of FSharp core library, that allows to process messages in a single thread.</p>
<pre><code class="language-FSharp">        member this.AddTodo todo =
            let f = fun () -&gt;
                ResultCE.result {
                    let! (_, tagState) = storage |&gt; getState&lt;TagsAggregate, TagEvent&gt; 
                    let tagIds = tagState.GetTags() |&gt;&gt; (fun x -&gt; x.Id)

                    let! tagIdIsValid =    
                        (todo.TagIds.IsEmpty ||
                        todo.TagIds |&gt; List.forall (fun x -&gt; (tagIds |&gt; List.contains x)))
                        |&gt; boolToResult &quot;A tag reference contained in the todo is related to a tag that does not exist&quot;

                    let! _ =
                        todo
                        |&gt; TodoCommand.AddTodo
                        |&gt; runCommand&lt;TodosAggregate, TodoEvent&gt; storage
                    let _ = 
                        storage
                        |&gt; mkSnapshotIfInterval&lt;TodosAggregate, TodoEvent&gt;
                return ()
            }
            async {
                return processor.PostAndReply (fun rc -&gt; f, rc)
            }
            |&gt; Async.RunSynchronously
</code></pre>
<p>The entire expression is wrapped in an async block and the processor.PostAndReply function is used to send the function f to the processor and wait for the result.</p>
<p>This approach is effective because ensure single thread processing but may slow down the processing of commands if the aggregate is involved in a long running transaction.</p>
<p>In some cases we may rather try to go back to explicit locks, in some cases it could be more convenient to use the mailboxprocessor and in other cases we may not use any sync mechanism at all!</p>
<p>If the problem is that the order is not preserved the fact that two &quot;todoAdded&quot; events are stored in a different order than how they are produced nobody cares. are actually.</p>
<p>At worst the event stored will be inconsistent and skipped by the &quot;evolve&quot;. So the &quot;no lock&quot; solution is a sort of optimistic locking that works in many cases. </p>
<p>Another example is the following, about sending commands to more aggregates.
This code removes the tag with any reference to it. It build two commands and make the repository process them at the same tim.
This code remove a tag and any reference to it.</p>
<pre><code class="language-FSharp">    member this.removeTag id =
        ResultCE.result {
            let removeTag = TagCommand.RemoveTag id
            let removeTagRef = TodoCommand.RemoveTagRef id
            let! _ = runTwoCommands&lt;TagsAggregate, TodosAggregate, TagEvent, TodoEvent&gt; storage removeTag removeTagRef
            return ()
        }
</code></pre>
<p>With reference to the example involving the &quot;under&quot; of a command: the runTwoCommands function is executed in a transactional context if the storage supports multiple streams transactions (i.e. Postgres or in memory).
In the case the storage does not support multiple streams transactions (i.e. Eventstoredb) the runTwoCommands function will execute the two commands in a sequence and uses the undoer (if provided) to rollback the effect of the first command in case the second command fails.</p>
<p>Source: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/App.fs">App.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repository"><a class="header" href="#repository">Repository</a></h1>
<p>The repository has the responsibility of:</p>
<ul>
<li>getting the state of an aggregate</li>
<li>trying to run commands passed, and eventually storing the related events returned by the command.</li>
<li>making periodic snapshots, according to the SnapshotsInterval parameter of the aggregate.
(remember tht snapshots are explicitly used only in the Postgres and InMemory storage implementations)</li>
</ul>
<p>Here an example of the private member that retrieve the last snapshot:</p>
<pre><code class="language-FSharp">    let inline private getLastSnapshot&lt;'A 
        when 'A: (static member Zero: 'A) 
        and 'A: (static member StorageName: string)
        and 'A: (static member Version: string)&gt;
        (storage: IStorage) = 

        ResultCE.result {
            let! result =
                match storage.TryGetLastSnapshot 'A.Version 'A.StorageName  with
                | Some (snapId, eventId, json) -&gt;
                    let state = SnapCache&lt;'A&gt;.Instance.Memoize (fun () -&gt; json |&gt; deserialize&lt;'A&gt;) snapId
                    match state with
                    | Error e -&gt; Error e
                    | _ -&gt; (eventId, state |&gt; Result.get) |&gt; Ok
                | None -&gt; (0, 'A.Zero) |&gt; Ok
            return result
        }
</code></pre>
<p>This function uses the storage to retrieve a triple of the snapshotId, the related eventId and the snapshot itself, serialized as json.
Note that the snapshot may be cached in memory, so that the deserialization is done only once.</p>
<p>To get the current state of an aggregate we need to get the last snapshot and the events that are after the snapshot.</p>
<p>Here is an older version of how to get the state:</p>
<pre><code class="language-Fsharp">    let inline getState&lt;'A, 'E
        when 'A: (static member Zero: 'A)
        and 'A: (static member StorageName: string)
        and 'A: (static member Version: string)
        and 'A: (static member LockObj: obj)
        and 'E :&gt; Event&lt;'A&gt;&gt;(storage: IStorage) = 

        let snapIdStateAndEvents()  =
            lock 'A.LockObj ( fun _ -&gt;
                ResultCE.result {
                    let! (id, state) = getLastSnapshot&lt;'A&gt; storage
                    let events = storage.GetEventsAfterId 'A.Version id 'A.StorageName
                    let result =
                        (id, state, events)
                    return result
                }
            )

        ResultCE.result {
            let! (lastSnapshotId, state, events) = snapIdStateAndEvents()
            let lastEventId =
                match events.Length with
                | x when x &gt; 0 -&gt; events |&gt; List.last |&gt; fst
                | _ -&gt; lastSnapshotId 
            let! events' =
                events |&gt;&gt; snd |&gt; catchErrors deserialize&lt;'E&gt;
            let! result =
                events' |&gt; evolve&lt;'A, 'E&gt; state

            return (lastEventId, result)
        }
</code></pre>
<p>Now I show the current implementation that enable the aggregate-state caching:</p>
<pre><code class="language-FSharp">    let inline getState&lt;'A, 'E
        when 'A: (static member Zero: 'A)
        and 'A: (static member StorageName: string)
        and 'A: (static member Version: string)
        and 'E :&gt; Event&lt;'A&gt;&gt;(storage: IStorage) = 

        let snapIdStateAndEvents()  =
            async {
                return
                    ResultCE.result {
                        let! (id, state) = getLastSnapshot&lt;'A&gt; storage
                        let events = storage.GetEventsAfterId 'A.Version id 'A.StorageName
                        let result =
                            (id, state, events)
                        return result
                    }
            }
            |&gt; Async.RunSynchronously

        let eventuallyFromCache = 
            fun () -&gt;
                ResultCE.result {
                    let! (lastSnapshotId, state, events) = snapIdStateAndEvents()
                    let lastEventId =
                        match events.Length with
                        | x when x &gt; 0 -&gt; events |&gt; List.last |&gt; fst
                        | _ -&gt; lastSnapshotId 
                    let! events' =
                        events |&gt;&gt; snd |&gt; catchErrors deserialize&lt;'E&gt;
                    let! result =
                        events' |&gt; evolve&lt;'A, 'E&gt; state
                    return (lastEventId, result)
                }
        let lastEventId = 
            async {
                return storage.TryGetLastEventId 'A.Version 'A.StorageName |&gt; Option.defaultValue 0
            } 
            |&gt; Async.RunSynchronously
        StateCache&lt;'A&gt;.Instance.Memoize (fun () -&gt; eventuallyFromCache()) (lastEventId, 'A.StorageName)
</code></pre>
<p>In the above code, the state is function of event id, and so we can use this eventId as the key of a cache that stores the state of the aggregate.</p>
<p>Note that here the evolve function is used, which is part of the core library.</p>
<p>There are actually two similar evolve implementation:</p>
<p>the basic implementation of the evolve is the one that cannot forgive any inconsistency in the  events passed as parameters with the current aggregate state:</p>
<pre><code class="language-Fsharp">    let inline evolveUNforgivingErrors&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; (h: 'A) (events: List&lt;'E&gt;) =
        events
        |&gt; List.fold
            (fun (acc: Result&lt;'A, string&gt;) (e: 'E) -&gt;
                match acc with
                    | Error err -&gt; Error err 
                    | Ok h -&gt; h |&gt; e.Process
            ) (h |&gt; Ok)
</code></pre>
<p>The previous version is not used to process stored events because, beside the in memory or postgres storage that are able to preserve consistency of the events stored (i.e. if the event are there then they must be consistent), there is the possibility of inconsistencies in the events that are stored in a general case by using directly the EventStoreDb or a message broker system.</p>
<p>Here an implementation of the evolve that skip eventual inconsistent events:</p>
<pre><code class="language-Fsharp">    let inline evolve&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; (h: 'A) (events: List&lt;'E&gt;): Result&lt;'A, string&gt; =
        let rec evolveSkippingErrors (acc: Result&lt;'A, string&gt;) (events: List&lt;'E&gt;) (guard: 'A) =
            match acc, events with
            | Error err, _::es -&gt; 
                // you may want to print or log this
                printf &quot;warning: %A\n&quot; err
                evolveSkippingErrors (guard |&gt; Ok) es guard
            | Error err, [] -&gt; 
                // you may want to print or log this
                printf &quot;warning: %A\n&quot; err
                guard |&gt; Ok
            | Ok state, e::es -&gt;
                let newGuard = state |&gt; e.Process
                match newGuard with
                | Error err -&gt; 
                    // use your favorite logging library here
                    printf &quot;warning: %A\n&quot; err
                    evolveSkippingErrors (guard |&gt; Ok) es guard
                | Ok h' -&gt;
                    evolveSkippingErrors (h' |&gt; Ok) es h'
            | Ok h, [] -&gt; h |&gt; Ok

        evolveSkippingErrors (h |&gt; Ok) events h
</code></pre>
<p>Code in <a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Lib/Repository.fs">Repository.fs</a> and
<a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Lib/Core.fs">Core.fs</a></p>
<p>There is also an experimental repository based on a publish/subscribe storage model (Eventstoredb).
See lightrepository</p>
<p><a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Lib/LightRepository.fs">LightRepository.fs</a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>A storage stores and retrieves events and snapshots related to each single aggregate.</p>
<p>In a strict way storage ensures transactionality particularly in special cases like when adding events related to multiple aggregates.</p>
<p>In a general sense there is the possibility of supporting storages that don't allow transactionality, and that is the case of the <em>EventStoreBridge</em> (or, in future, Kafa etc..)</p>
<p>Here the abstract definition of members required for a storage:</p>
<pre><code class="language-FSharp">    abstract member Reset: version -&gt; Name -&gt; unit
    abstract member TryGetLastSnapshot: version -&gt; Name -&gt; Option&lt;int * int * Json&gt;
    abstract member TryGetLastEventId: version -&gt; Name -&gt; Option&lt;int&gt;
    abstract member TryGetLastSnapshotEventId: version -&gt; Name -&gt; Option&lt;int&gt;
    abstract member TryGetLastSnapshotId: version -&gt; Name -&gt; Option&lt;int&gt;
    abstract member TryGetEvent: version -&gt; int -&gt; Name -&gt; Option&lt;StorageEvent&gt;
    abstract member SetSnapshot: version -&gt; int * Json -&gt; Name -&gt; Result&lt;unit, string&gt;
    abstract member AddEvents: version -&gt; List&lt;Json&gt; -&gt; Name -&gt; Result&lt;unit, string&gt;
    abstract member MultiAddEvents:  List&lt;List&lt;Json&gt; * version * Name&gt;  -&gt; Result&lt;unit, string&gt;
    abstract member GetEventsAfterId: version -&gt; int -&gt; Name -&gt; List&lt;int * string &gt;
</code></pre>
<p>Reset must be used only for development and test, and cannot be used in production. See Conf.fs.</p>
<p>An example of a storage implementation in postgres: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/DbStorage.fs">DbStorage.fs</a></p>
<h1 id="eventstorebridge"><a class="header" href="#eventstorebridge">EventStoreBridge:</a></h1>
<p>The alternative storage is the EventStoreBridge, which is a bridge to the EventStore database.
It is still experimental.
<a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib.EventStore/EventStoreBridge.cs">EventStoreBridge.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactoring-strategy"><a class="header" href="#refactoring-strategy">Refactoring strategy</a></h1>
<p>By aggregate refactoring I mean when we have the same models, the same application behavior and we just move  models from one aggregate to another.</p>
<p>Here I am showing a strategy for refactoring aggregates in terms of:</p>
<ul>
<li>moving the models ownership between aggregates, </li>
<li>introducing new aggregates </li>
<li>upgrading old aggregates.</li>
<li>dropping aggregates.</li>
</ul>
<p>The problem arise because it looks overcomplicated d to make upfront decision about aggregates.</p>
<p>It looks to me more convenient having few aggregate, for instance in a development and prototyping stage because this will simplify testing, prototyping, building the application service layer.
Consider the extreme when we have everithing in a single aggregate. It would mean that the application service layer will be able to handle all the models with few lines of code (just building single command for the repository)</p>
<p>However, at a later stage, a proper refactoring is probably needed by moving models to different aggregates or creating new aggregates for performance reasons.</p>
<p>Refactoring aggregates in that sense means leaving the application service layer behavior unchanged.</p>
<p>The steps that may be followed are:</p>
<ul>
<li>defining new aggregates and eventually create upgraded version of current aggregates</li>
<li>moving models ownership from old aggregates to new aggregates (or to updated versions of the same aggregates which is the same)</li>
<li>creating an upgraded version of the application service layer using the new set of aggregates</li>
<li>applying the equivalent tests of the previous service layer to the new one.</li>
</ul>
<p>About this latest point, a parametric testing strategy is also possible.</p>
<p>Here is anexample of a list of tuples of multiple application version configuration with migration function.</p>
<pre><code class="language-FSharp">let allVersions =
    [
        (AppVersions.applicationPostgresStorage,        AppVersions.applicationPostgresStorage,       fun () -&gt; () |&gt; Result.Ok)
        (AppVersions.applicationShadowPostgresStorage,  AppVersions.applicationShadowPostgresStorage, fun () -&gt; () |&gt; Result.Ok)
        (AppVersions.applicationPostgresStorage,        AppVersions.applicationShadowPostgresStorage, AppVersions.applicationPostgresStorage._migrator.Value)

        (AppVersions.applicationMemoryStorage,          AppVersions.applicationMemoryStorage,         fun () -&gt; () |&gt; Result.Ok)
        (AppVersions.applicationShadowMemoryStorage,    AppVersions.applicationShadowMemoryStorage,   fun () -&gt; () |&gt; Result.Ok)
        (AppVersions.applicationMemoryStorage,          AppVersions.applicationShadowMemoryStorage,   AppVersions.applicationMemoryStorage._migrator.Value)
    ]
</code></pre>
<p>There are specific attributes to distinguish current and &quot;upgrading&quot; verion of elements of the application. </p>
<p>A migration function is needed to move data from old aggregates to new aggregates.</p>
<p>Code here: <a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Sample.Test/MultiVersionsTests.fs">MultiVersionsTests.fs</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
