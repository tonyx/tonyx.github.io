<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">2.</strong> Entities</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">3.</strong> Aggregates</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">4.</strong> Events</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">5.</strong> Commands</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">6.</strong> Application Layer</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">7.</strong> Repository</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">8.</strong> Storage</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">9.</strong> Refactoring</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">10.</strong> Testing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/tonyx/Micro_ES_FSharp_Lib">Sharpino</a> is a simple F# event sourcing framework.
It is a project for study and for experimenting.
At the moment (2023-08-06) it supports <em>in memory</em> and <em>Postgres</em> storage.
There is also experimental support for <em>EventstoreDB</em>.</p>
<p>Here I am giving a quick overview of how it works, how the sample application works (from the entities to the application service layer and without any user interface) and how to handle aggregate refactoring.</p>
<h2 id="the-sample-application"><a class="header" href="#the-sample-application">The sample application</a></h2>
<p>The sample application is a todo list manager. Each todo contains references to Tags and Categories.
There are two versions of the same application that use different aggregate configurations.</p>
<p>The &quot;version 1&quot; has an Aggregate managing Todo and Categories, and another aggregate managing Tags.</p>
<p>The &quot;version 2&quot; of the application consists of three different aggregates: one for the Todo model, one for the Categories model, and another one for the Tags model.</p>
<p>The challenge is that you can write parametric tests that can be executed against the current and the next aggregate configuration, also by testing the migration between the former and the latter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p>With <strong>Sharpino</strong> we essentially manage collections of entities. We can think about them in the same way as we used to while approaching the &quot;trantitional&quot; application development. Records in a relational database. 
In general, any entity has no direct reference to any other entity but may reference them by their id (as an extenal reference).  So for instance a todo may contain a list of tag ids and a list of category ids that are related to it (any todo may have zero or more tags and zero or more categories).
However there can be exceptions for models that are closely related: for instance, you may rather define an <em>order</em> entity and an <em>order item</em> entity in the same place so that any orders can contain a direct reference to order items instead of the id of order items (by using this approach you would represent the order items as a list of order items instead of a list of order item ids).</p>
<p>Here there is my todo entity definition:</p>
<pre><code class="language-FSharp">    type Todo =
        {
            Id: Guid
            CategoryIds : List&lt;Guid&gt;
            TagIds: List&lt;Guid&gt;
            Description: string
        }
    type Todos =
        {
            todos: List&lt;Todo&gt;
        }
        with
            static member Zero =
                {
                    todos = []
                }
</code></pre>
<p>Sometimes I will use the term &quot;model&quot; to refer to an entity or to a collection of entities. For instance, the &quot;Todos&quot; model is a collection of &quot;Todo&quot; entities.</p>
<p>You've seen a special &quot;Zero&quot; static member. The aggregate will use it to define its own <em>Zero</em> static member which is mandatory for any aggregate.
The <em>Zero</em> static member is the initial state of the aggregate and it is used to rebuild the state of the aggregate when there are no events stored for that aggregate.
Note that in some popular full-stack development FSharp technologies (<a href="https://safe-stack.github.io">&quot;Safe stack&quot;</a> and specifically <a href="https://github.com/Zaid-Ajaj/Fable.Remoting">Fable remoting</a>) definitions of entities that must be accessed on the client side (using Fsharp technology transpiled in javascript, i.e. <a href="https://fable.io">Fable</a>) must stay in a separate project shared between the client and the server. 
In that case, we would define the &quot;Todo&quot;, the &quot;Tag&quot; and the &quot;Category&quot; types in a shared project so an eventual Fable/Elmish client application can use them.</p>
<p>Source: <a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Sample/models/TodosModel.fs">TodosModel.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregates"><a class="header" href="#aggregates">Aggregates</a></h1>
<p>An aggregate is an instance of a class (or more properly, a record) that handles one or more collections of entities. We will be able to recreate the state of the aggregate by processing the stored events by the  <em>evolve</em> function. As we will see later, the <em>events</em> are closely related to some of the members of the aggregate. </p>
<p>Given that the state of the aggregate is a function of the related events processed and stored, an aggregate needs the following information associated that I defined as mandatory, static members:</p>
<ul>
<li>
<p><strong>Zero</strong>: the instance of the aggregate in its initial state. 
It is needed to be able to provide the state of the aggregate when there is no event stored related to that aggregate.</p>
</li>
<li>
<p><strong>StorageName</strong> and  <strong>Version</strong>: this combination uniquely identifies the aggregate and lets the storage know in which stream to store events and snapshots.</p>
</li>
<li>
<ul>
<li><strong>LockObject</strong>: (<em>warning: the lockobject concept is obsolete. It was meant to handle single-thread processing but at the moment I am providing an actor model based mailboxprocessor to ensure single-thread chain command-&gt;events-&gt;eventstoring, so you will skip this part</em>). Before introducing the <em>mailboxprocessor</em> (i.e. an actor model single thread message processor), the repository was supposed to use aggregate locks while processing commands and storing related events ensuring consistency using pessimistic locking. An application layer was also supposed to use them explicitly to ensure inter-aggregate integrity (invariant conditions involving models handled by separate aggregates).</li>
</ul>
</li>
<li>
<p><strong>SnapshotsInterval</strong>: the number of the events that can be stored after a snapshot before creating a new snapshot (i.e. the number of events between snapshots)</p>
</li>
</ul>
<p>In all my current implementations of storage  (<em>in memory</em>,  <em>Postgres</em> and <em>EventstoreDb</em>)  the state of any aggregate is rebuilt starting from the latest available snapshot and applying the events that are after the snapshot. The current state of any aggregate may also be cached.</p>
<p>Example:</p>
<pre><code class="language-FSharp">    type TodosAggregate =
        {
            todos: Todos
            categories: Categories
        }
        static member Zero =
            {
                todos = Todos.Zero
                categories = Categories.Zero
            }
        static member StorageName =
            &quot;_todo&quot;
        static member Version =
            &quot;_01&quot;
        static member SnapshotsInterval =
            15
</code></pre>
<p>Some members of the aggregate virtually change the state of the aggregate in the sense that they return an instance of the aggregate in a different state or an error. It means that such members will <em>add/update/delete</em>  some of their entities (still in a functional/immutable way i.e. returning a new collection with some changes). Those members will be associated with aggregate <em>events</em> (see next section).
In the following example, the aggregate of the Todos manages also the categories, so it will be able to check the validity of the categories referenced by a todo before adding it (to preserve the rule that you can add only todo with category-Ids related to existing categories).
It uses the &quot;result&quot; computational expression included in the FsToolkit.ErrorHandling library which supports the <a href="https://fsharpforfunandprofit.com/rop/"><em>railway-oriented programming</em></a> pattern of handling errors.</p>
<p>Example:</p>
<pre><code class="language-FSharp">    member this.AddTodo (t: Todo) =
        let checkCategoryExists (c: Guid ) =
            this.categories.GetCategories() 
            |&gt; List.exists (fun x -&gt; x.Id = c) 
            |&gt; boolToResult (sprintf &quot;A category with id '%A' does not exist&quot; c)

        result
            {
                let! categoriesMustExist = t.CategoryIds |&gt; catchErrors checkCategoryExists
                let! todos = this.todos.AddTodo t
                return 
                    {
                        this with
                            todos = todos
                    }
            }
</code></pre>
<p>Wrap-up: We can protect invariant conditions related to models that are part of the same aggregate without the need for any explicit transaction because at that level there is no awareness of the storage. Still, I will show that we can protect other invariant conditions that may involve models residing in different aggregates at the service application layer (see in the next sections) running commands involving multiple streams. This sometimes will involve the use of explicit transactions when supported by the storage (i.e. Postgres), and sometimes will involve the &quot;undoer&quot;: a special command attached to a command to undo the changes made by the command itself (see the next sections).</p>
<p>Source code: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/aggregates/Todos/Aggregate.fs">TodosAggregate.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>As I said before, some members of an aggregate act as &quot;state changers&quot;, operating add/update/delete on one or more of its models. 
Each aggregate has events and commands as discriminated unions (DU).</p>
<p>An event is something that, when processed, returns a new state of the aggregate or an error, which fits the following definition:</p>
<pre><code class="language-FSharp">    type Event&lt;'A&gt; =
        abstract member Process: 'A -&gt; Result&lt;'A, string&gt;
</code></pre>
<p>The <em>'A</em> is the generic aggregate type the event is associated with.</p>
<p>This is an example of a concrete implementation of an event related to the TodoAggregate members <em>Add</em> and <em>Remove</em>:</p>
<pre><code class="language-Fsharp">    type TodoEvent =
        | TodoAdded of Todo
        | TodoRemoved of Guid
            interface Event&lt;TodosAggregate&gt; with
                member this.Process (x: TodosAggregate ) =
                    match this with
                    | TodoAdded (t: Todo) -&gt; 
                        x.AddTodo t
                    | TodoRemoved (g: Guid) -&gt; 
                        x.RemoveTodo g

</code></pre>
<p>This shows that processing an event means calling the related aggregate member.</p>
<p>You can do event caching by wrapping the call to the specific aggregate member in a lambda expression without evaluating it and passing it to a specific cache manager that may eventually evaluate it and return the result or the cached result if the event has already been processed.</p>
<pre><code class="language-Fsharp">    type TodoEvent =
        | TodoAdded of Todo
        | TodoRemoved of Guid
            interface Event&lt;TodosAggregate&gt; with
                member this.Process (x: TodosAggregate ) =
                    match this with
                    | TodoAdded (t: Todo) -&gt; 
                        EventCache&lt;TodosAggregate&gt;.Instance.Memoize (fun () -&gt; x.AddTodo t) (x, [TodoAdded t]) 
                    | TodoRemoved (g: Guid) -&gt; 
                        EventCache&lt;TodosAggregate&gt;.Instance.Memoize (fun () -&gt; x.RemoveTodo g) (x, [TodoRemoved t]) 
</code></pre>
<p>Having said that about caching, I am warning that caching events don't look so much like a &quot;performance booster&quot;. It looks more promising the caching of the state of the aggregate (see the next section).</p>
<p>Therefore event Caching is disabled by default. See &quot;EVENTS_CACHING_ENABLED&quot; in the project file: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/Sharpino.Lib.fsproj">project file</a>
To enable the caching of events, the library must be compiled with the following compilation symbol: <code>EVENTS_CACHING_ENABLED</code>.</p>
<p>Source code:  <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/aggregates/Todos/Events.fs">Events.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>We define a command type for each aggregate.
A Command type is concretely represented by a Discriminated Union. Executing the command on a specific aggregate means returning a proper list of events that can be applied (processed) to the aggregate or an error.
We have also <em>&quot;command undoers&quot;</em>, that allow us to compensate the effect of a command in case it is part of a multiple stream transaction that fails as we will see later. An undoer issues the events that can reverse the effect of the command.</p>
<p>The abstract definitions of Command and Undoer  are:</p>
<pre><code class="language-FSharp">
    type Undoer&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; = 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;

    type Command&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; Result&lt;Undoer&lt;'A, 'E&gt;, string&gt;&gt;

</code></pre>
<p>Example:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        | AddTodo of Todo
        | RemoveTodo of Guid

        interface Command&lt;TodosAggregate, TodoEvent&gt; with
            member this.Execute (x: TodosAggregate) =
                match this with
                | AddTodo t -&gt; 
                    match x.AddTodo t with
                    | Ok _ -&gt; [TodoAdded] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
                | RemoveTodo g -&gt;
                    match
                        x.RemoveTodo g with
                        | Ok _ -&gt; [TodoEvent.TodoRemoved g] |&gt; Ok
                        | Error x -&gt; x |&gt; Error
            member this.Undoer = None
</code></pre>
<p>It is possible, although uncommon, to have, for a command, cases that can return multiple events as follows:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        [...]
        | Add2Todos of Todo * Todo
        interface Command&lt;TodosAggregate, TodoEvent&gt; with
            member this.Execute (x: TodosAggregate) =
            [...]
            match this with
            | Add2Todos (t1, t2) -&gt; 
                let evolved =
                    fun () -&gt;
                    [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2]
                    |&gt; evolveUNforgivingErrors x
                match evolved() with
                    | Ok _ -&gt; [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
            member this.Undoer

</code></pre>
<p>Any command must ensure that it will return Result.Ok (and therefore, one or more events) only if the events to be returned, when processed with the current aggregate state, give an Ok result, i.e. a valid aggregate state (and no error). 
For that reason, before returning the events, I invoked the &quot;evolveUNforgivingErrors&quot; function to &quot;probe&quot; the sequence of two events to be eventually returned. 
The evolveUNforgivingErrors processes some events to a given state of the aggregate returning an error or a valid state.
There is also a similar function <em>evolve</em> which is more tolerant and will just skip events that, when processed give error, and can return a valid aggregate state anyway. 
The way evolve can forgive inconsistent events is a form of optimistic locking: it lets to add any events to the storage even if they will end up in an inconsistent state. That means: you can avoid single thread, or locks in command processing.</p>
<p>Commands can use event caching if it is enabled as we have seen in the previous section.</p>
<h2 id="undoer"><a class="header" href="#undoer">Undoer</a></h2>
<p>I already mentioned that a command case in a command type definition may have associated an <em>undoer</em> which is similar to a command itself, but it is aimed to eventually do the &quot;reverse&quot; of a command, which means compensating the effect of a command in case such command is part of a multiple stream transaction that fails. We need the <em>undoer</em> only if the storage lack of multiple streams transactions (which is the case of EventStoreDb)</p>
<pre><code class="language-FSharp">    type Undoer&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; = 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;
</code></pre>
<p>So, as a recap: when the repository uses storages like <em>in memory</em> or <em>Postgres</em>, it doesn't need any <em>undoer</em> because those storages support multiple stream transactions.
If you will use an EventStoreDb-like engine as storage, you may want to provide an <em>undoer</em> for each command case.</p>
<p>I am going to show an example of an <em>undoer</em>. Let me remind the abstract definition of a command.</p>
<pre><code class="language-FSharp">    type Command&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; Result&lt;Undoer&lt;'A, 'E&gt;, string&gt;&gt;
</code></pre>
<p>Given the current state of the aggregate, the &quot;command undoer&quot; returns a function that, applied to the aggregate state, must return the actual <em>undoer</em>.</p>
<p>So the undoers work in two shots: one to build a context for the eventual future undo, and one to actually... <em>do</em> the <em>undo!</em>. </p>
<p><strong>Example of &quot;undoer&quot;</strong> :</p>
<p>The <em>RemoveTag</em> command returns a list of TagRemoved events. We know that when those events are processed the result is the aggregate without the tags.
However, we may want to roll back the effect of those events by adding events that reverse their effect.</p>
<p>This applies to a transaction context: you need to be able to re-add the tag to the aggregate state. For this reason, you need to build a context <em>before</em> the removal so that the tag to be eventually readded is still available.</p>
<p>From the code with some comments:</p>
<pre><code class="language-Fsharp">    member this.Undoer = 
        match this with
        | RemoveTag g -&gt; 
            // block to be executed before the actual command removing tag 
            // is executed. It will return another function with the context needed (the tag itself)
            (fun (x: TagsAggregate) -&gt;
                result {
                    let! tag = x.GetTag g
                    let result =

                        // block to be executed after the actual command removing tag is executed.  
                        // It will return the list of events to be applied to the aggregate state to compensate the effect of the command. 
                        // Note that the tag is the context needed to readd the tag to the aggregate state.

                        fun (x': TagsAggregate) -&gt;
                            x'.AddTag tag 
                            |&gt; Result.map (fun _ -&gt; [TagAdded tag])
                    return result
                }
            )
            |&gt; Some
        | AddTag t -&gt;
            // this case is simple than the previous because there is no need to retrieve anything from the context before the command is executed. 
            // The context is the tag itself (particularly its id), that can't be lost during the transaction.
            (fun (_: TagsAggregate) -&gt;
                fun (x': TagsAggregate) -&gt;
                    x'.RemoveTag t.Id 
                    |&gt; Result.map (fun _ -&gt; [TagAdded t])
                |&gt; Ok
            )
            |&gt; Some

</code></pre>
<p>Source code: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/aggregates/Todos/Commands.fs">Commands.fs</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-service-layer"><a class="header" href="#application-service-layer">Application service layer</a></h1>
<p>An application service layer provides services that use Repository and Storage to get the state and/or send commands to one or more aggregates (eventually in an atomic/transactional way with potential issues already discussed).</p>
<p>Here is one of the simplest examples of an entry for a service involving a single aggregate, by building and running an AddTag command.</p>
<pre><code class="language-FSharp">    member this.addTag tag =
        result {
            let! _ =
                tag
                |&gt; AddTag
                |&gt; (runCommand&lt;TagsAggregate, TagEvent&gt; storage)
            return ()
        }
</code></pre>
<p>The service layer sends commands to the repository so that this one can run it producing and storing the related events.</p>
<p>The following example shows a service layer that uses two aggregates and an explicit lock (note that the lock object concept to handle transactions has been substituted by a mailboxprocessor (actor model). Still I'm not sure if the lock object approach deserved to be dismissed).
As mentioned in the previous section its not a big deal avoiding any locking or mailboxprocessor (single thread) command processing: the worst that may happen is that the events stored are inconsistent and will be skipped by the &quot;evolve&quot; function.</p>
<p>I will show an example involving the new version right after this one.</p>
<pre><code class="language-FSharp">    member this.addTodo todo =
        lock TagsAggregate.LockObj &lt;| fun () -&gt;
            result {
                let! (_, tagState) = getState&lt;TagsAggregate, TagEvent&gt;(storage)
                let tagIds = tagState.GetTags() |&gt;&gt; (fun x -&gt; x.Id)

                let! tagIdIsValid =    
                    (todo.TagIds.IsEmpty ||
                    todo.TagIds |&gt; List.forall (fun x -&gt; (tagIds |&gt; List.contains x)))
                    |&gt; boolToResult &quot;A tag reference contained is in the todo is related to a tag that does not exist&quot;

                return! 
                    todo
                    |&gt; TodoCommand.AddTodo
                    |&gt; (runCommand&lt;TodosAggregate, TodoEvent&gt; storage)
            }
</code></pre>
<p>The todo can be added only if it contains valid tag references.</p>
<p>Now I am showing how I decided to deal with the same issue of making the code safe  (transactional) by using the mailboxprocessor, part of FSharp core library, that allows processing messages in a single thread.</p>
<pre><code class="language-FSharp">        member this.AddTodo todo =
            let f = fun () -&gt;
                ResultCE.result {
                    let! (_, tagState) = storage |&gt; getState&lt;TagsAggregate, TagEvent&gt; 
                    let tagIds = tagState.GetTags() |&gt;&gt; (fun x -&gt; x.Id)

                    let! tagIdIsValid =    
                        (todo.TagIds.IsEmpty ||
                        todo.TagIds |&gt; List.forall (fun x -&gt; (tagIds |&gt; List.contains x)))
                        |&gt; boolToResult &quot;A tag reference contained in the todo is related to a tag that does not exist&quot;

                    let! _ =
                        todo
                        |&gt; TodoCommand.AddTodo
                        |&gt; runCommand&lt;TodosAggregate, TodoEvent&gt; storage
                    let _ = 
                        storage
                        |&gt; mkSnapshotIfInterval&lt;TodosAggregate, TodoEvent&gt;
                return ()
            }
            async {
                return processor.PostAndReply (fun rc -&gt; f, rc)
            }
            |&gt; Async.RunSynchronously
</code></pre>
<p>The entire expression is wrapped in an async block and the processor.PostAndReply function is used to send the function f to the processor and wait for the result (again: the processor is a single thread message processor that may not be required anymore).</p>
<p>Basically this approach ensures single-thread processing but may slow down the processing of commands if the aggregate is involved in a long-running transaction.</p>
<p>Another example is the following, about sending commands to more aggregates.
This code removes the tag with any reference to it. It builds two commands and makes the repository process them at the same time.
This code removes a tag and any reference to it.</p>
<pre><code class="language-FSharp">    member this.removeTag id =
        ResultCE.result {
            let removeTag = TagCommand.RemoveTag id
            let removeTagRef = TodoCommand.RemoveTagRef id
            let! _ = runTwoCommands&lt;TagsAggregate, TodosAggregate, TagEvent, TodoEvent&gt; storage removeTag removeTagRef
            return ()
        }
</code></pre>
<p>About to the example involving the &quot;under&quot; of a command: the runTwoCommands function is executed in a transactional context if the storage supports multiple streams transactions (i.e. Postgres or in memory).
In the case the storage does not support multiple streams transactions (i.e. Eventstoredb) the runTwoCommands function will execute the two commands in a sequence and use the undoers (if provided) to rollback the effect of the first command in case the second command fails.</p>
<p>Source: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/App.fs">App.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repository"><a class="header" href="#repository">Repository</a></h1>
<p>The repository has the responsibility of:</p>
<ul>
<li>getting the state of an aggregate</li>
<li>trying to run commands passed, and eventually storing the related events returned by the command.</li>
<li>making periodic snapshots, according to the SnapshotsInterval parameter of the aggregate.
(Remember that snapshots are explicitly used only in the Postgres and in-memory storage implementations)</li>
</ul>
<p>Here is an example of the private member that retrieves the last snapshot:</p>
<pre><code class="language-FSharp">    let inline private getLastSnapshot&lt;'A 
        when 'A: (static member Zero: 'A) 
        and 'A: (static member StorageName: string)
        and 'A: (static member Version: string)&gt;
        (storage: IStorage) = 

        ResultCE.result {
            let! result =
                match storage.TryGetLastSnapshot 'A.Version 'A.StorageName  with
                | Some (snapId, eventId, json) -&gt;
                    let state = SnapCache&lt;'A&gt;.Instance.Memoize (fun () -&gt; json |&gt; deserialize&lt;'A&gt;) snapId
                    match state with
                    | Error e -&gt; Error e
                    | _ -&gt; (eventId, state |&gt; Result.get) |&gt; Ok
                | None -&gt; (0, 'A.Zero) |&gt; Ok
            return result
        }
</code></pre>
<p>This function uses the storage to retrieve a triple of the snapshot-Id, the related eventId and the snapshot itself, serialized as json.
Note that the snapshot may be cached in memory so that the deserialization is done only once.</p>
<p>To get the current state of an aggregate we need to get the last snapshot and the events that are after the snapshot.</p>
<p>Here is an older version of how to get the state:</p>
<pre><code class="language-Fsharp">    let inline getState&lt;'A, 'E
        when 'A: (static member Zero: 'A)
        and 'A: (static member StorageName: string)
        and 'A: (static member Version: string)
        and 'A: (static member LockObj: obj)
        and 'E :&gt; Event&lt;'A&gt;&gt;(storage: IStorage) = 

        let snapIdStateAndEvents()  =
            lock 'A.LockObj ( fun _ -&gt;
                ResultCE.result {
                    let! (id, state) = getLastSnapshot&lt;'A&gt; storage
                    let events = storage.GetEventsAfterId 'A.Version id 'A.StorageName
                    let result =
                        (id, state, events)
                    return result
                }
            )

        ResultCE.result {
            let! (lastSnapshotId, state, events) = snapIdStateAndEvents()
            let lastEventId =
                match events.Length with
                | x when x &gt; 0 -&gt; events |&gt; List.last |&gt; fst
                | _ -&gt; lastSnapshotId 
            let! events' =
                events |&gt;&gt; snd |&gt; catchErrors deserialize&lt;'E&gt;
            let! result =
                events' |&gt; evolve&lt;'A, 'E&gt; state

            return (lastEventId, result)
        }
</code></pre>
<p>Now I show the current implementation that enables aggregate-state caching:</p>
<pre><code class="language-FSharp">    let inline getState&lt;'A, 'E
        when 'A: (static member Zero: 'A)
        and 'A: (static member StorageName: string)
        and 'A: (static member Version: string)
        and 'E :&gt; Event&lt;'A&gt;&gt;(storage: IStorage) = 

        let snapIdStateAndEvents()  =
            async {
                return
                    ResultCE.result {
                        let! (id, state) = getLastSnapshot&lt;'A&gt; storage
                        let events = storage.GetEventsAfterId 'A.Version id 'A.StorageName
                        let result =
                            (id, state, events)
                        return result
                    }
            }
            |&gt; Async.RunSynchronously

        let eventuallyFromCache = 
            fun () -&gt;
                ResultCE.result {
                    let! (lastSnapshotId, state, events) = snapIdStateAndEvents()
                    let lastEventId =
                        match events.Length with
                        | x when x &gt; 0 -&gt; events |&gt; List.last |&gt; fst
                        | _ -&gt; lastSnapshotId 
                    let! events' =
                        events |&gt;&gt; snd |&gt; catchErrors deserialize&lt;'E&gt;
                    let! result =
                        events' |&gt; evolve&lt;'A, 'E&gt; state
                    return (lastEventId, result)
                }
        let lastEventId = 
            async {
                return storage.TryGetLastEventId 'A.Version 'A.StorageName |&gt; Option.defaultValue 0
            } 
            |&gt; Async.RunSynchronously
        StateCache&lt;'A&gt;.Instance.Memoize (fun () -&gt; eventuallyFromCache()) (lastEventId, 'A.StorageName)
</code></pre>
<p>In the above code, the state is a function of eventId, and so we can use this eventId as the key of a cache that stores the state of the aggregate.</p>
<p>Note that here the evolve function is used, which is part of the core library.</p>
<p>There are actually two similar evolve implementations:</p>
<p>The basic implementation of the evolve is the one that cannot forgive any inconsistency in the  events passed as parameters with the current aggregate state:</p>
<pre><code class="language-Fsharp">    let inline evolveUNforgivingErrors&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; (h: 'A) (events: List&lt;'E&gt;) =
        events
        |&gt; List.fold
            (fun (acc: Result&lt;'A, string&gt;) (e: 'E) -&gt;
                match acc with
                    | Error err -&gt; Error err 
                    | Ok h -&gt; h |&gt; e.Process
            ) (h |&gt; Ok)
</code></pre>
<p>Here is an implementation of the evolve that skips eventual inconsistent events:</p>
<pre><code class="language-Fsharp">    let inline evolve&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; (h: 'A) (events: List&lt;'E&gt;): Result&lt;'A, string&gt; =
        let rec evolveSkippingErrors (acc: Result&lt;'A, string&gt;) (events: List&lt;'E&gt;) (guard: 'A) =
            match acc, events with
            | Error err, _::es -&gt; 
                // you may want to print or log this
                printf &quot;warning: %A\n&quot; err
                evolveSkippingErrors (guard |&gt; Ok) es guard
            | Error err, [] -&gt; 
                // you may want to print or log this
                printf &quot;warning: %A\n&quot; err
                guard |&gt; Ok
            | Ok state, e::es -&gt;
                let newGuard = state |&gt; e.Process
                match newGuard with
                | Error err -&gt; 
                    // use your favorite logging library here
                    printf &quot;warning: %A\n&quot; err
                    evolveSkippingErrors (guard |&gt; Ok) es guard
                | Ok h' -&gt;
                    evolveSkippingErrors (h' |&gt; Ok) es h'
            | Ok h, [] -&gt; h |&gt; Ok

        evolveSkippingErrors (h |&gt; Ok) events h
</code></pre>
<p>Code in <a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Lib/Repository.fs">Repository.fs</a> and
<a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Lib/Core.fs">Core.fs</a></p>
<p>There is also an experimental repository based on a publish/subscribe storage model (Eventstoredb).
See <em>lightrepository</em></p>
<p><a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Lib/LightRepository.fs">LightRepository.fs</a> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>A storage stores and retrieves events and snapshots related to each single aggregate.</p>
<p>In a strict way storage ensures transactionality particularly in special cases like when adding events related to multiple aggregates.</p>
<p>In a general sense, there is the possibility of supporting storages that lack transactionality between multiple streams,  and that is the case of the <em>EventStoreBridge</em> (or, in the future, Kafa etc..)</p>
<p>Here is the abstract definition of members required for storage:</p>
<pre><code class="language-FSharp">    abstract member Reset: version -&gt; Name -&gt; unit
    abstract member TryGetLastSnapshot: version -&gt; Name -&gt; Option&lt;int * int * Json&gt;
    abstract member TryGetLastEventId: version -&gt; Name -&gt; Option&lt;int&gt;
    abstract member TryGetLastSnapshotEventId: version -&gt; Name -&gt; Option&lt;int&gt;
    abstract member TryGetLastSnapshotId: version -&gt; Name -&gt; Option&lt;int&gt;
    abstract member TryGetEvent: version -&gt; int -&gt; Name -&gt; Option&lt;StorageEvent&gt;
    abstract member SetSnapshot: version -&gt; int * Json -&gt; Name -&gt; Result&lt;unit, string&gt;
    abstract member AddEvents: version -&gt; List&lt;Json&gt; -&gt; Name -&gt; Result&lt;unit, string&gt;
    abstract member MultiAddEvents:  List&lt;List&lt;Json&gt; * version * Name&gt;  -&gt; Result&lt;unit, string&gt;
    abstract member GetEventsAfterId: version -&gt; int -&gt; Name -&gt; List&lt;int * string &gt;
</code></pre>
<p>Reset must be used only for development and testing, and cannot be used in production. See Conf.fs.</p>
<p>An example of a storage implementation in Postgres: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/DbStorage.fs">DbStorage.fs</a></p>
<h1 id="eventstorebridge"><a class="header" href="#eventstorebridge">EventStoreBridge:</a></h1>
<p>The alternative storage is the EventStoreBridge, which is a bridge to the EventStore database.
It is still experimental.
<a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/EventStoreStorage.fs">EventStoreBridge.fs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactoring-strategy"><a class="header" href="#refactoring-strategy">Refactoring strategy</a></h1>
<p>By aggregate refactoring I mean when we just move models (collection of entities) from one aggregate to another.</p>
<p>Here I am showing a strategy for refactoring aggregates in terms of:</p>
<ul>
<li>moving the model's ownership between aggregates, </li>
<li>introducing new aggregates </li>
<li>upgrading old aggregates.</li>
<li>dropping aggregates.</li>
</ul>
<p>The problem arises because it looks overcomplicated d to make upfront decisions about aggregates.</p>
<p>It looks to me more convenient to have a few aggregates, for instance in a development and prototyping stage because this will simplify testing, prototyping, and building the application service layer.
Consider the extreme when we have everything in a single aggregate. It would mean that the application service layer will be able to handle all the models with few lines of code (just building single command for the repository)</p>
<p>However, at a later stage, proper refactoring is probably needed by moving models to different aggregates or creating new aggregates for performance reasons.</p>
<p>Refactoring aggregates in that sense means leaving the application service layer behavior unchanged.</p>
<p>The steps that may be followed are:</p>
<ul>
<li>defining new aggregates and eventually creating upgraded versions of current aggregates</li>
<li>moving model ownership from old aggregates to new aggregates (or to updated versions of the same aggregates which is the same)</li>
<li>creating an upgraded version of the application service layer using the new set of aggregates</li>
<li>applying the equivalent tests of the previous service layer to the new one.</li>
</ul>
<p>About this latest point, a parametric testing strategy is also possible.</p>
<p>Here is an example of a list of tuples of multiple application version configurations with migration functions.</p>
<pre><code class="language-FSharp">let allVersions =
    [
        (applicationPostgresStorage,        applicationPostgresStorage,       fun () -&gt; () |&gt; Result.Ok)
        (applicationShadowPostgresStorage,  applicationShadowPostgresStorage, fun () -&gt; () |&gt; Result.Ok)
        (applicationPostgresStorage,        applicationShadowPostgresStorage, applicationPostgresStorage._migrator.Value)

        (applicationMemoryStorage,          applicationMemoryStorage,         fun () -&gt; () |&gt; Result.Ok)
        (applicationShadowMemoryStorage,    applicationShadowMemoryStorage,   fun () -&gt; () |&gt; Result.Ok)
        (applicationMemoryStorage,          applicationShadowMemoryStorage,   applicationMemoryStorage._migrator.Value)
    ]
</code></pre>
<p>There are specific attributes to distinguish current and &quot;upgrading&quot; versions of elements of the application. </p>
<p>A migration function is needed to move data from old aggregates to new aggregates.</p>
<p>Code here: <a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Sample.Test/MultiVersionsTests.fs">MultiVersionsTests.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>As I mentioned in the previous chapter we may have different versions of the same application based on different distribution of entities and aggregates and/or different storages.</p>
<p>We may want to test all of them and also we may want to test the migration function from one version to another in those tests.
A structure of a parametric test that considers various possible combinations of application versions and migration functions is the following:</p>
<pre><code class="language-FSharp">
        multipleTestCase &quot;test something &quot; versions &lt;| fun (ap, apUpgd, migrator)  -&gt;
            let _ = ap._reset()

            // test something on ap, which is the &quot;initial version&quot; 
            // of the application
            .....

            // then migrate from &quot;ap&quot; version to apUpgd version 
            // using its migrator function

            let migrated = migrator()
            Expect.isOk migrated &quot;should be ok&quot;

            // test something on apUpgd, which is the &quot;upgraded version&quot; of the application

</code></pre>
<p>In some cases, you just want to run your tests fast and you don't want to test everything against all the possible combinations of application versions.</p>
<p>Then you may just skip some of the versions set up in the &quot;version&quot; triples <strong>(initversion, endversion, migrator)</strong> by commenting out temporarily the ones you don't want to spend time to test at the moment:</p>
<pre><code class="language-FSharp">let allVersions =
    [

        // (AppVersions.currentPostgresApp,        AppVersions.currentPostgresApp,     fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.upgradedPostgresApp,       AppVersions.upgradedPostgresApp,    fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.currentPostgresApp,        AppVersions.upgradedPostgresApp,    AppVersions.currentPostgresApp._migrator.Value)

        (AppVersions.currentMemoryApp,          AppVersions.currentMemoryApp,       fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.upgradedMemoryApp,         AppVersions.upgradedMemoryApp,      fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.currentMemoryApp,          AppVersions.upgradedMemoryApp,      AppVersions.currentMemoryApp._migrator.Value)

        // (AppVersions.evSApp,                    AppVersions.evSApp,                 fun () -&gt; () |&gt; Result.Ok)
    ]

</code></pre>
<p>The above code enables only the tests of the current version of the app that uses the in-memory storage.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
