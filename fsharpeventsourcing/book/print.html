<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">2.</strong> Entities</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">3.</strong> Aggregates</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">4.</strong> Events</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">5.</strong> Commands</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">6.</strong> Application Layer</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">7.</strong> Repository</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">8.</strong> Storage</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">9.</strong> Refactoring</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">10.</strong> Testing</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">11.</strong> Apache Kafka</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/tonyx/Micro_ES_FSharp_Lib">Sharpino</a> is a little F# event sourcing framework.
<em>Contexts</em>:  Objects that can be event sourced. There is no specific id for a context so we just assume that a single instance and a single zero (initial state) instance exist for any <em>Context</em>.
<em>Aggregates</em>: Objects that can be event sourced. Many instances of an aggregate can exist at a time so we need an Id for each instance represented by a Guid. The initial state for any aggregate will end up in an initial snapshot in the event store.</p>
<p>Contexts and aggregates need to define members that do Add/Remove/Update operations functionally and by using Result type to handle errors. We tipically use Railway oriented programming is used to handle errors in any Add/Remove/Update operation (by the FsTookit.ErrorHandling library).</p>
<p>Contexts and aggregates need to specify event types associated with Add/Remove/Update operations. 
Event types need associated commands
Commands and events must be Discriminated Union types implementing the <em>Command</em> and the <em>Event</em> interfaces respectively.</p>
<p>This document is a guide to the Sharpino library. It is a work in progress.
Focus on the following topics:
Contexts, events, commands, service application layer, Event Store.</p>
<h2 id="the-sample-application-1"><a class="header" href="#the-sample-application-1">The sample application 1.</a></h2>
<p>This sample is convoluted and represent unlikely situations like having complex relations and interactions between different aggregates/contexts. I would suggest to 
skip this part. I'd say the interesting proposal in this example is about the refactoring technique: how to move from a specific distribution of concerns between contexts/aggregate to another distribution.
How to test the migration of the context/aggregate.
The idea is to create a new version of context/aggregate and at the same time build a migration function.</p>
<p>Each todo contains references to Tags and Categories.
I'll show how we can handle two versions of the same application that use different cluster configurations. This will help to talk about the context refactoring.</p>
<p>The &quot;version 1&quot; has a context managing Todo and Categories, and another context managing Tags.</p>
<p>The &quot;version 2&quot; of the application consists of three different contexts: one for the Todo model, one for the Categories model, and another one for the Tags model.</p>
<h2 id="sample-application-2-booking-system-for-seats-in-a-stadium"><a class="header" href="#sample-application-2-booking-system-for-seats-in-a-stadium">Sample application 2. Booking system for seats in a stadium</a></h2>
<p>Contexts represent rows. Some constraints are applied to the rows. The context is responsible for the seats. The seats are associated with the rows.</p>
<h2 id="sample-application-4-booking-system-for-seats-in-a-stadium"><a class="header" href="#sample-application-4-booking-system-for-seats-in-a-stadium">Sample application 4. Booking system for seats in a stadium</a></h2>
<p>The same as application 2 but where rows are aggregates (so I can have any number of instances of seat rows). The application uses the SAFE based stack based template son can publish the system as a rest service using the Fable Remoting library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p>I am representing in this example the Todo entity and a Todo context</p>
<p>This is the Todo entity definition:</p>
<pre><code class="language-FSharp">    type Todo =
        {
            Id: Guid
            CategoryIds : List&lt;Guid&gt;
            TagIds: List&lt;Guid&gt;
            Description: string
        }
    type Todos =
        {
            todos: List&lt;Todo&gt;
        }
        with
            static member Zero =
                {
                    todos = []
                }
</code></pre>
<p>The Todos context needs also some other members (to handle the stream name, the serialize/deserialize functions, and the snapshots interval...)</p>
<p>The Context will define a <em>Zero</em> static member (initial state).
In case we use 
<a href="https://github.com/Zaid-Ajaj/Fable.Remoting">Fable remoting</a>)
then we need to share the definition of the entities between the client and the server side.
(Shared project)</p>
<p>Source: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample.Shared/Entities.fs">TodosModel.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="context"><a class="header" href="#context">Context</a></h1>
<p>A context is a class meant to be event-sourced, i.e. associated with a stream of events.
To buld the state of a context using stored events we use the <em>evolve</em> function.</p>
<p><em>events</em> are associated to members of the cluster that end up in Update/Delete/Remove of some entity</p>
<p>Static members that are mandatory for any cluster of entities are:</p>
<ul>
<li>
<p><strong>Zero</strong>: the initial state (no events yet).</p>
</li>
<li>
<p><strong>StorageName</strong> and  <strong>Version</strong>: this combination uniquely identifies the cluster and lets the storage know in which stream to store events and snapshots. Whatever will be the storage (memory, Postgres, EventstoreDb, etc.) the cluster will be stored in a stream named as the concatenation of the <em>StorageName</em> and the <em>Version</em> (i.e. &quot;_todo_01&quot;)</p>
</li>
<li>
<p><strong>SnapshotsInterval</strong>: the number of events that can be stored after a snapshot before creating a new snapshot (i.e. the number of events between snapshots).</p>
</li>
</ul>
<p>The Command handler, by the runCommand function, applies a command, then stores the related events and returns the EventStore (database) IDs of those stored events and the KafkaDeliveryResult (if Kafka broker is enabled).</p>
<p>Example of a cluster of entities handling the todos and the categories:</p>
<pre><code class="language-FSharp">    type TodosCluster =
        {
            todos: Todos
            categories: Categories
        }
        static member Zero =
            {
                todos = Todos.Zero
                categories = Categories.Zero
            }
        static member StorageName =
            &quot;_todo&quot;
        static member Version =
            &quot;_01&quot;
        static member SnapshotsInterval =
            15
</code></pre>
<p>In the following example, the TodosContext can check the validity of the categories referenced by any todo before adding it (to preserve the invariant rule that you can add only todo with valid category ID references).
It uses the &quot;result&quot; computational expression included in the FsToolkit.ErrorHandling library which supports the <a href="https://fsharpforfunandprofit.com/rop/"><em>railway-oriented programming</em></a> pattern of handling errors.</p>
<p>Example:</p>
<pre><code class="language-FSharp">    member this.AddTodo (t: Todo) =
        let checkCategoryExists (c: Guid ) =
            this.categories.GetCategories() 
            |&gt; List.exists (fun x -&gt; x.Id = c) 
            |&gt; boolToResult (sprintf &quot;A category with id '%A' does not exist&quot; c)

        result
            {
                let! categoriesMustExist = t.CategoryIds |&gt; catchErrors checkCategoryExists
                let! todos = this.todos.AddTodo t
                return 
                    {
                        this with
                            todos = todos
                    }
            }
</code></pre>
<p>Todo: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/Domain/Todos/Context.fs">Context.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>Events are discriminated unions (DU) with cases associated with members of the context that end up in <em>adding</em>/<em>updating</em>/<em>deleting</em>/ entities.</p>
<p>When we process an event it returns a new state or an error: </p>
<pre><code class="language-FSharp">    type Event&lt;'A&gt; =
        abstract member Process: 'A -&gt; Result&lt;'A, string&gt;
</code></pre>
<p>The <em>'A</em> is the generic context or aggregate type, the event is associated with.</p>
<p>This is an example of a concrete implementation of an event related to the TodoCluster members <em>Add</em> and <em>Remove</em>.</p>
<p>So, for example, the <em>TodoAdded</em> event is associated with the <em>AddTodo</em> member.
The <em>Process</em> member of the event is implemented by calling the related clusters member.</p>
<pre><code class="language-Fsharp">    type TodoEvent =
        | TodoAdded of Todo
        | TodoRemoved of Guid
            interface Event&lt;TodosCluster&gt; with
                member this.Process (x: TodosContext ) =
                    match this with
                    | TodoAdded (t: Todo) -&gt; 
                        x.AddTodo t
                    | TodoRemoved (g: Guid) -&gt; 
                        x.RemoveTodo g

</code></pre>
<p>Source code:  <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/Domain/Todos/Events.fs">Events.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>(this section needs an update as we have a new )</p>
<p>A Command type is a Discriminated Union. Executing the command on a specific cluster or aggregate means returning a proper list of events or an error.
You can also specify <em>&quot;command undoers&quot;</em>, that allow you to compensate the effect of a command in case it is part of a multiple stream transaction that fails as we will see later. An undoer issues the events that can reverse the effect of the related command.
For example, the &quot;under&quot; of AddTodo is the related RemoveTodo (see next paragraph).</p>
<p>In the following code we can see the signature for any state viewers for any context or aggregate. State viewer corresponds to read models: they will provide the current state of aggregate or context. Typically, that state may come from a cache, from the event store (by processing the events) or from a topic of Kafa (or eventually any other message/event broker, even though I haven't implemented completed any of them yet).</p>
<pre><code class="language-FSharp">
    type StateViewer&lt;'A&gt; = unit -&gt; Result&lt;EventId * 'A, string&gt;
    type AggregateViewer&lt;'A&gt; = Guid -&gt; Result&lt;EventId * 'A,string&gt;
    
    type Aggregate&lt;'F&gt; =
        abstract member Id: Guid // use this one to be able to filter related events from same string
        abstract member Serialize: 'F
    
    type Event&lt;'A&gt; =
        abstract member Process: 'A -&gt; Result&lt;'A, string&gt;

    type Command&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;'A * List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; StateViewer&lt;'A&gt; -&gt; Result&lt;unit -&gt; Result&lt;List&lt;'E&gt;, string&gt;, string&gt;&gt;
        
    type AggregateCommand&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;'A * List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; AggregateViewer&lt;'A&gt; -&gt; Result&lt;unit -&gt; Result&lt;List&lt;'E&gt;, string&gt;, string&gt;&gt;


</code></pre>
<p>Example:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        | AddTodo of Todo
        | RemoveTodo of Guid

        interface Command&lt;TodosContext, TodoEvent&gt; with
            member this.Execute (x: TodosContext) =
                match this with
                | AddTodo t -&gt; 
                    match x.AddTodo t with
                    | Ok _ -&gt; [TodoAdded] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
                | RemoveTodo g -&gt;
                    match
                        x.RemoveTodo g with
                        | Ok _ -&gt; [TodoEvent.TodoRemoved g] |&gt; Ok
                        | Error x -&gt; x |&gt; Error
            member this.Undoer = None
</code></pre>
<p>A command may return more than one event:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        [...]
        | Add2Todos of Todo * Todo
        interface Command&lt;TodosCluster, TodoEvent&gt; with
            member this.Execute (x: TodosContext) =
            [...]
            match this with
            | Add2Todos (t1, t2) -&gt; 
                let evolved =
                    fun () -&gt;
                    [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2]
                    |&gt; evolveUNforgivingErrors x
                match evolved() with
                    | Ok _ -&gt; [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
            member this.Undoer

</code></pre>
<p>Any command must ensure that it will return Result.OK (and therefore, one or more events) only if the events to be returned, when processed on the current state, return an Ok result, i.e. a valid state (and no error). </p>
<p>The <em>evolve</em> tolerates inconsistent events.
Thus the <em>evolve</em> will just skip events that, when processed, return an error.
This feature is associated with a specific permissive optimistic lock type that we will see later.</p>
<h2 id="undoer"><a class="header" href="#undoer">Undoer</a></h2>
<p>The use of the lambda expression is a nice trick for the undoers (the <em>under</em> is returned as a lambda that retrieves the context for applying the undo and returns another lambda that actually can &quot;undo&quot; the command).</p>
<p>I haven't simplified any example of undoer yet, but this is the idea related to commands for adding and removing items </p>
<pre><code class="language-fsharp">module CartCommands =
    type CartCommands =
    | AddGood of Guid * int
    | RemoveGood of Guid
        interface AggregateCommand&lt;Cart, CartEvents&gt; with
            member this.Execute (cart: Cart) =
                match this with
                | AddGood (goodRef, quantity) -&gt; 
                    cart.AddGood (goodRef, quantity)
                    |&gt; Result.map (fun s -&gt; (s, [GoodAdded (goodRef, quantity)]))
                | RemoveGood goodRef -&gt;
                    cart.RemoveGood goodRef
                    |&gt; Result.map (fun s -&gt; (s, [GoodRemoved goodRef]))
            member this.Undoer = 
                match this with
                | AddGood (goodRef, _) -&gt; 
                    Some 
                        (fun (cart: Cart) (viewer: AggregateViewer&lt;Cart&gt;) -&gt;
                            result {
                                let! (i, _) = viewer (cart.Id) 
                                return
                                    fun () -&gt;
                                        result {
                                            let! (j, state) = viewer (cart.Id)
                                            let! isGreater = 
                                                (j &gt;= i)
                                                |&gt; Result.ofBool (sprintf &quot;execution undo state '%d' must be after the undo command state '%d'&quot; j i)
                                            let result =
                                                state.RemoveGood goodRef
                                                |&gt; Result.map (fun _ -&gt; [GoodRemoved goodRef])
                                            return! result
                                        }
                                }
                        )
                | RemoveGood goodRef -&gt;
                    Some
                        (fun (cart: Cart) (viewer: AggregateViewer&lt;Cart&gt;) -&gt;
                            result {
                                let! (i, state) = viewer (cart.Id) 
                                let! goodQuantity = state.GetGoodAndQuantity goodRef
                                return
                                    fun () -&gt;
                                        result {
                                            let! (j, state) = viewer (cart.Id)
                                            let! isGreater = 
                                                // this check depends also on the number of events generated by the command (i.e. the j &gt;= (i+1) if command generates 2 event)
                                                (j &gt;= i)
                                                |&gt; Result.ofBool (sprintf &quot;execution undo state '%d' must be after the undo command state '%d'&quot; j i)
                                            let result =
                                                state.AddGood (goodRef, goodQuantity)
                                                |&gt; Result.map (fun _ -&gt; [GoodAdded (goodRef, goodQuantity)])
                                            return! result
                                        }
                                }
                        )
</code></pre>
<p>Probably to follow the example its worth reading again the definition of an undoer:</p>
<pre><code class="language-FSharp">        abstract member Undoer: Option&lt;'A -&gt; AggregateViewer&lt;'A&gt; -&gt; Result&lt;unit -&gt; Result&lt;List&lt;'E&gt;, string&gt;, string&gt;&gt;
</code></pre>
<p>This can be simplified as the state of the aggregate is accessed in different ways, however this is the meaning:</p>
<p>Extract from the current state of the aggregate useful info for a future &quot;rollback&quot;/&quot;undo&quot; and return a function that, when applied to the current state of the aggregate, will return the events that will &quot;undo&quot; the effect of the command.</p>
<p>Saga like transaction handling will probably need this logic.
However, most of the time the commands between multiple aggregates uses db transactions (like Postgres) and the undoer is not needed.</p>
<p><a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/Domain/Tags/Commands.fs">Commands.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-service-layer"><a class="header" href="#application-service-layer">Application service layer</a></h1>
<p>An application service layer implements multiple context logic.
Here is one of the simplest examples of an entry for a service involving a single context, by building and running an AddTag command.</p>
<pre><code class="language-FSharp">        member this.AddTag tag =
            result {
                let! result =
                    tag
                    |&gt; AddTag
                    |&gt; runCommand&lt;TagsContext, TagEvent&gt; storage eventBroker tagsStateViewer
                return result 
            }
</code></pre>
<p>As in the previous example, the service layer sends commands to the Command Handler so that this one can run it producing and storing the related events, returning the EventStore Ids of the stored events and the KafkaDeliveryResult (if Kafka broker is enabled).</p>
<p>We may adopt strong and immediate consistency by enforcing the use of a pessimistic lock on the command handler.
An example of explicit use of lock:</p>
<pre><code class="language-FSharp">    member this.addTodo todo =
        lock TagsCluster.LockObj &lt;| fun () -&gt;
            result {
                let! (_, tagState) = getState&lt;TagsCluster, TagEvent&gt;(storage)
                let tagIds = tagState.GetTags() |&gt;&gt; (fun x -&gt; x.Id)

                let! tagIdIsValid =    
                    (todo.TagIds.IsEmpty ||
                    todo.TagIds |&gt; List.forall (fun x -&gt; (tagIds |&gt; List.contains x)))
                    |&gt; boolToResult &quot;A tag reference contained is in the todo is related to a tag that does not exist&quot;

                return! 
                    todo
                    |&gt; TodoCommand.AddTodo
                    |&gt; (runCommand&lt;TodosCluster, TodoEvent&gt; storage)
            }
</code></pre>
<p>The todo can be added only if it contains valid tag references.</p>
<h2 id="running-two-commands-to-different-clusters"><a class="header" href="#running-two-commands-to-different-clusters">Running two commands to different clusters</a></h2>
<p>This code removes the tag with any reference to it. It builds two commands and makes the repository process them at the same time.
This code removes a tag and any reference to it.</p>
<pre><code class="language-FSharp">    member this.removeTag id =
        ResultCE.result {
            let removeTag = TagCommand.RemoveTag id
            let removeTagRef = TodoCommand.RemoveTagRef id
            return! runTwoCommands&lt;TagsCluster, TodosCluster, TagEvent, TodoEvent&gt; storage removeTag removeTagRef
        }
</code></pre>
<p>The <em>runTwoCommands</em> uses the undoer if the current event store requires it (i.e. it lacks multiple stream transactions).</p>
<p>Source: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/App.fs">App.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-handler"><a class="header" href="#command-handler">Command Handler</a></h1>
<p>The Command Handler has the responsibility of:</p>
<ul>
<li>getting the state</li>
<li>trying to run commands passed, and eventually storing the related events.</li>
<li>making periodic snapshots, according to the SnapshotsInterval.</li>
</ul>
<p>There are two different command handler implementations:</p>
<p><a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/CommandHandler.fs">CommandHandler.fs</a></p>
<p>There is also an experimental repository based on a publish/subscribe storage model (Eventstoredb).
See <em>lightrepository</em></p>
<p><a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/LightCommandHandler.fs">LightCommandHandler.fs</a></p>
<p>Note: from version 1.4.7 the commandHandler can use a Kafka broker to retrieve the current state.
That means that the commandHandler can be used in a distributed environment, where the state is stored in a Kafka topic.
Moreover, it can anyway rely on the EventStoreDb to rebuild the current state in case of failure of the Kafka broker (for example when events are out of sync).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eventstore-database"><a class="header" href="#eventstore-database">EventStore (database)</a></h1>
<p>An event-store, stores and retrieves events and snapshots related to each single context.</p>
<p>An example of a storage implementation in Postgres: 
<a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/PgEventStore.fs">DbStorage.fs</a></p>
<h1 id="eventstoredb"><a class="header" href="#eventstoredb">EventStoreDb:</a></h1>
<p>The alternative storage is the EventStoreBridge, which is a bridge to the EventStore database.
It is still experimental.
<a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/EventStoreStorage.fs">EventStoreStorage.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactoring-strategy"><a class="header" href="#refactoring-strategy">Refactoring strategy</a></h1>
<p>By cluster refactoring, I mean when we just move models (collections of entities) among contexts.</p>
<p>Here I am showing a strategy for refactoring in terms of:</p>
<ul>
<li>moving the model's ownership between contexts, </li>
<li>introducing new contexts </li>
<li>upgrading old contexts.</li>
<li>dropping contexts.</li>
</ul>
<p>The problem arises because it looks overcomplicated d to make upfront decisions about contexts. Consider that an application may start, for simplicity, with a single context and then, at a later stage, we may want to split it into multiple contexts.</p>
<p>Refactoring leaves the application service layer behavior unchanged.</p>
<p>The steps that may be followed are:</p>
<ul>
<li>defining new contexts and eventually creating upgraded versions of current contexts</li>
<li>moving collection of entities from contexts to others.</li>
<li>creating an upgraded version of the application service layer using the new versions</li>
<li>applying the equivalent tests of the previous service layer to the new one.</li>
</ul>
<p>About this latest point, a parametric testing strategy is also possible.</p>
<p>Here is an example of a list of tuples of multiple application version configurations with migration functions.</p>
<pre><code class="language-FSharp">let allVersions =
    [
        (applicationPostgresStorage,        applicationPostgresStorage,       fun () -&gt; () |&gt; Result.Ok)
        (applicationShadowPostgresStorage,  applicationShadowPostgresStorage, fun () -&gt; () |&gt; Result.Ok)
        (applicationPostgresStorage,        applicationShadowPostgresStorage, applicationPostgresStorage._migrator.Value)

        (applicationMemoryStorage,          applicationMemoryStorage,         fun () -&gt; () |&gt; Result.Ok)
        (applicationShadowMemoryStorage,    applicationShadowMemoryStorage,   fun () -&gt; () |&gt; Result.Ok)
        (applicationMemoryStorage,          applicationShadowMemoryStorage,   applicationMemoryStorage._migrator.Value)
    ]
</code></pre>
<p>There are specific attributes to distinguish current and &quot;upgrading&quot; versions of elements of the application. </p>
<p>A migration function is needed to extract data from the current version and store it in the upgraded version.</p>
<p>Code here: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample.Test/MultiVersionsTests.fs">MultiVersionsTests.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>As I mentioned in the previous chapter we may have different versions of the same application based on different clusters.</p>
<p>We may want to test all of them and also we may want to test the migration function from one version to another in those tests.
A structure of a parametric test that considers various possible combinations of application versions and migration functions is the following:</p>
<pre><code class="language-FSharp">
        multipleTestCase &quot;test something &quot; versions &lt;| fun (ap, apUpgd, migrator)  -&gt;
            let _ = ap._reset()

            // test something on ap, which is the &quot;initial version&quot; 
            // of the application
            .....

            // then migrate from &quot;ap&quot; version to apUpgd version 
            // using its migrator function

            let migrated = migrator()
            Expect.isOk migrated &quot;should be ok&quot;

            // test something on apUpgd, which is the &quot;upgraded version&quot; of the application

</code></pre>
<p>In some cases, you just want to run your tests fast and you don't want to test everything against all the possible combinations of application versions.</p>
<p>Then you may just skip some of the versions set up in the &quot;version&quot; triples <strong>(initversion, endversion, migrator)</strong> by commenting out temporarily the ones you don't want to spend time to test at the moment:</p>
<pre><code class="language-FSharp">let allVersions =
    [

        // (AppVersions.currentPostgresApp,        AppVersions.currentPostgresApp,     fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.upgradedPostgresApp,       AppVersions.upgradedPostgresApp,    fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.currentPostgresApp,        AppVersions.upgradedPostgresApp,    AppVersions.currentPostgresApp._migrator.Value)

        (AppVersions.currentMemoryApp,          AppVersions.currentMemoryApp,       fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.upgradedMemoryApp,         AppVersions.upgradedMemoryApp,      fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.currentMemoryApp,          AppVersions.upgradedMemoryApp,      AppVersions.currentMemoryApp._migrator.Value)

        // (AppVersions.evSApp,                    AppVersions.evSApp,                 fun () -&gt; () |&gt; Result.Ok)
    ]

</code></pre>
<p>The above code enables only the tests of the current version of the app that uses the in-memory storage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-kafka"><a class="header" href="#apache-kafka">Apache Kafka</a></h1>
<p>We can use Apache Kafka to notify events after storing them.
The style is the outbox pattern (without db).
Examples of usage are <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/AppVersions.fs">here</a>.
Some tests are instrumented to eventually listen to Apache Kafka, see <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample.Test/MultiVersionsTests.fs">here</a>.
Any &quot;view&quot; node may build its own view of the cluster state by listening to the events.
KafkaStateViewer and KafkaAggregateStateViewer are able to build the current state by subscribing events on specific topics and specific partitions of topics.</p>
<p>Command handler is able to use read models given by KafkaStateViewer.
Kafka based state viewer will be able to detect anomaly by checking the progressive id of any event.
In case of such anomaly the state viewer will be able to access to the event store to build the state.</p>
<p>This part is still under development to be optmized.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
