<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">2.</strong> Entities</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">3.</strong> Aggregates</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">4.</strong> Events</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">5.</strong> Commands</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">6.</strong> Application Layer</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">7.</strong> Repository</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">8.</strong> Storage</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">9.</strong> Refactoring</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">10.</strong> Testing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/tonyx/Micro_ES_FSharp_Lib">Sharpino</a> is a little F# event sourcing framework.
Even though the example provided are closer to the concept of 
At the moment (2023-08-06) it supports <em>in memory</em>, <em>Postgres</em> and _EventStoreDb as storage for events.</p>
<p>The framework is based on the concept of <em>clusters</em> and <em>command</em> around clusters.
A cluster is a set of collections of entities. A command is a request to a cluster to perform an action involving one or more entities.</p>
<p>This doc is quick overview of how Sharpino works by means of its sample application: a Todo list manager with tags and categories. Tags and categories work as a way to classify todos. We will see the difference between having a single cluster managing all the entities and having separate clusters for different entities.</p>
<p>I'll focus on: entities, cluster, events, commands, service application layer, repository and storages.
I'll also mention the problem of undoing a command and how to handle cluster refactoring (moving entities from one cluster to another and at the same time testing all those configurations).</p>
<h2 id="the-sample-application"><a class="header" href="#the-sample-application">The sample application</a></h2>
<p>As already mentioned the sample application is a todo list manager. Each todo contains references to Tags and Categories.
I'll show how we can handle two versions of the same application that use different cluster configurations. This will help to talk about the cluster refactoring.</p>
<p>The &quot;version 1&quot; has a cluster managing Todo and Categories, and another cluster managing Tags.</p>
<p>The &quot;version 2&quot; of the application consists of three different clusters: one for the Todo model, one for the Categories model, and another one for the Tags model.</p>
<p>The challenge about being able to write parametric tests that can be executed against the current and the next cluster configuration at the same time, having the migration between the former and the latter configuration.
That means that you may avoid caring about the cluster configuration when prototyping the application. Creating cluster will means no more than partitioning the set of the collections of entities. </p>
<p>A prototype of an application may start with a single cluster managing all the entities. Then, when the application grows, you may want to split the cluster in two or more clusters. This is what I call &quot;cluster refactoring&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p>I can represent entities as records. They needs a unique identifier (Id). 
In general, any entity has no direct reference to any other entity. However it  may reference other entities them by their id (as an extenal reference, similar to the concept of foreign key).  So for instance a <em>todo</em> may contain a list of ids of tags  and a list of ids of categories that are related to it (any todo may reference zero or more tags and zero or more categories).
You may change this approach and refer entities in direct way rather than using key: for instance, if you have an <em>order</em> entity and an <em>order item</em> entity you may prefer that order items are a list of actual orderitem type rather than a list of ids. Just remember that you can't have circular dependencies in F# (unless you explicitely use keywords like <em>rec</em> and <em>and</em>). </p>
<p>Here there is my todo entity definition:</p>
<pre><code class="language-FSharp">    type Todo =
        {
            Id: Guid
            CategoryIds : List&lt;Guid&gt;
            TagIds: List&lt;Guid&gt;
            Description: string
        }
    type Todos =
        {
            todos: List&lt;Todo&gt;
        }
        with
            static member Zero =
                {
                    todos = []
                }
</code></pre>
<p>Note that sometimes I may use the term &quot;model&quot; to refer to an entity or to a collection of entities. For instance, the &quot;Todos&quot; model is a collection of &quot;Todo&quot; entities.</p>
<p>It is a good practice to define an explicit &quot;Zero&quot; static member for entitiy. The cluster will use it to define its own <em>Zero</em> static member which is mandatory for clusters: So a cluster expose its <em>Zero</em> by means of the <em>Zero</em> of its entities.
The <em>Zero</em> static member for a cluster is mandatory and represents its initial state.<br />
Note that in a popular full-stack development FSharp technology (<a href="https://safe-stack.github.io">&quot;Safe stack&quot;</a> which ingludes <a href="https://github.com/Zaid-Ajaj/Fable.Remoting">Fable remoting</a>) the definitions of the entities that are shared among the client side (Fable to Javascript node based app) and the server side (.net core web service based app) <a href="https://fable.io">Fable</a>). So the definition of the entities need to stay in a separate project shared referenced by the the client and the server projects.
This means that we would define the &quot;Todo&quot;, the &quot;Tag&quot; and the &quot;Category&quot; types in a shared project.</p>
<p>Source: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/entities/Todos.fs">TodosModel.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clusters"><a class="header" href="#clusters">Clusters</a></h1>
<p>A cluster is just a group of collections of entities that form a transactional boundary.
Clusters will be associated with streams of events.
You can get the current state of any cluster by processing the stored events using the <em>evolve</em> function.  <em>events</em> are closely related to members of the cluster that end up in Update/Delete/Remove of some entity (even though there is no actual change because we are using immutable data structures).</p>
<p>Static members that are mandatory for any cluster of entities are:</p>
<ul>
<li>
<p><strong>Zero</strong>: the initial state (no events yet).</p>
</li>
<li>
<p><strong>StorageName</strong> and  <strong>Version</strong>: this combination uniquely identifies the cluster and lets the storage know in which stream to store events and snapshots. Whatever will be the storage (memory, Postgres, EventstoreDb, etc.) the cluster will be stored in a stream named as the concatenation of the <em>StorageName</em> and the <em>Version</em> (i.e. &quot;_todo_01&quot;)</p>
</li>
<li>
<p><strong>Lock</strong>: a lock object is used to protect the cluster from concurrent access.
The Command handler uses Locks. An application layer may use locks when involves multiple streams of events.</p>
</li>
<li>
<p><strong>SnapshotsInterval</strong>: the number of events that can be stored after a snapshot before creating a new snapshot (i.e. the number of events between snapshots)</p>
</li>
</ul>
<p>The Command handler returns the updated state of any cluster by applying the events that are stored after the latest valid state (which is cached in memory).
The Command handler is also able to rebuild the state starting from the last stored snapshot.</p>
<p>Example of a cluster of entities handling the todos and the categories:</p>
<pre><code class="language-FSharp">    type TodosCluster =
        {
            todos: Todos
            categories: Categories
        }
        static member Zero =
            {
                todos = Todos.Zero
                categories = Categories.Zero
            }
        static member StorageName =
            &quot;_todo&quot;
        static member Version =
            &quot;_01&quot;
        static member SnapshotsInterval =
            15
</code></pre>
<p>Some instance members virtually change the state in the sense that they return a new instance in a different state or an error. It means that such members will <em>add/update/delete</em> some of their entities. you need to associate those members with <em>events</em> and <em>commands</em> (see next section).
In the following example, the TodosCluster can check the validity of the categories referenced by any todo before adding it (to preserve the invariant rule that you can add only todo with valid category ID references).
It uses the &quot;result&quot; computational expression included in the FsToolkit.ErrorHandling library which supports the <a href="https://fsharpforfunandprofit.com/rop/"><em>railway-oriented programming</em></a> pattern of handling errors.</p>
<p>Example:</p>
<pre><code class="language-FSharp">    member this.AddTodo (t: Todo) =
        let checkCategoryExists (c: Guid ) =
            this.categories.GetCategories() 
            |&gt; List.exists (fun x -&gt; x.Id = c) 
            |&gt; boolToResult (sprintf &quot;A category with id '%A' does not exist&quot; c)

        result
            {
                let! categoriesMustExist = t.CategoryIds |&gt; catchErrors checkCategoryExists
                let! todos = this.todos.AddTodo t
                return 
                    {
                        this with
                            todos = todos
                    }
            }
</code></pre>
<p>Conclusions: In adding/removing/updating entities in a cluster we can protect any invariant conditions related to other entities that are under the same cluster without the need for any explicit transaction. We can protect other invariant conditions that may involve entities of other clusters anyway. This will be possible at the service application layer (see in the next sections) running commands involving multiple streams of events. This sometimes will involve the use of explicit transactions when supported by the storage (i.e. Postgres), and sometimes will involve the &quot;undoer&quot;: a special command attached to a command to undo the changes made by the command itself (see the next sections), useful when the storage does not support multiple stream transactions.</p>
<p>Source code: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/clusters/Todos/Cluster.fs">TodosCluster.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>Events are discriminated unions (DU) with cases associated with members of the cluster doing <em>add</em>/<em>update</em>/<em>delete</em>/ entities.</p>
<p>When we process an event it returns a new state or an error, which fits the following definition of Process taken from the Core.fs file:</p>
<pre><code class="language-FSharp">    type Event&lt;'A&gt; =
        abstract member Process: 'A -&gt; Result&lt;'A, string&gt;
</code></pre>
<p>The <em>'A</em> is the generic cluster type the event is associated with.</p>
<p>This is an example of a concrete implementation of an event related to the TodoCluster members <em>Add</em> and <em>Remove</em>.</p>
<p>So, for example, the <em>TodoAdded</em> event is associated with the <em>AddTodo</em> member.
The <em>Process</em> member of the event is implemented by calling the related clusters member.</p>
<pre><code class="language-Fsharp">    type TodoEvent =
        | TodoAdded of Todo
        | TodoRemoved of Guid
            interface Event&lt;TodosCluster&gt; with
                member this.Process (x: TodosCluster ) =
                    match this with
                    | TodoAdded (t: Todo) -&gt; 
                        x.AddTodo t
                    | TodoRemoved (g: Guid) -&gt; 
                        x.RemoveTodo g

</code></pre>
<p>Source code:  <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/aggregates/Todos/Events.fs">Events.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>A Command type is a Discriminated Union. Executing the command on a specific cluster means returning a proper list of events or an error.
You can also specify <em>&quot;command undoers&quot;</em>, that allow you to compensate the effect of a command in case it is part of a multiple stream transaction that fails as we will see later. An undoer issues the events that can reverse the effect of the related command.
For instance, the &quot;under&quot; of AddTodo is the related RemoveTodo (see next paragraph).</p>
<p>The abstract definitions of Command and Undoer  are:</p>
<pre><code class="language-FSharp">
    type Undoer&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; = 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;

    type Command&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; Result&lt;Undoer&lt;'A, 'E&gt;, string&gt;&gt;

</code></pre>
<p>Example:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        | AddTodo of Todo
        | RemoveTodo of Guid

        interface Command&lt;TodosCluster, TodoEvent&gt; with
            member this.Execute (x: TodosCluster) =
                match this with
                | AddTodo t -&gt; 
                    match x.AddTodo t with
                    | Ok _ -&gt; [TodoAdded] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
                | RemoveTodo g -&gt;
                    match
                        x.RemoveTodo g with
                        | Ok _ -&gt; [TodoEvent.TodoRemoved g] |&gt; Ok
                        | Error x -&gt; x |&gt; Error
            member this.Undoer = None
</code></pre>
<p>It is possible, although uncommon, to have, for a command, cases that can return multiple events as follows:</p>
<pre><code class="language-FSharp">    type TodoCommand =
        [...]
        | Add2Todos of Todo * Todo
        interface Command&lt;TodosCluster, TodoEvent&gt; with
            member this.Execute (x: TodosClusten) =
            [...]
            match this with
            | Add2Todos (t1, t2) -&gt; 
                let evolved =
                    fun () -&gt;
                    [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2]
                    |&gt; evolveUNforgivingErrors x
                match evolved() with
                    | Ok _ -&gt; [TodoEvent.TodoAdded t1; TodoEvent.TodoAdded t2] |&gt; Ok
                    | Error x -&gt; x |&gt; Error
            member this.Undoer

</code></pre>
<p>Any command must ensure that it will return Result.Ok (and therefore, one or more events) only if the events to be returned, when processed on the current state, give an Ok result, i.e. a valid state (and no error). </p>
<p>Even though the Command Handler using lock ensures immediate consistency, the <em>evolve</em> tolerates inconsistent events.
Thus the <em>evolve</em> will just skip events that, when processed, return an error.</p>
<h2 id="undoer"><a class="header" href="#undoer">Undoer</a></h2>
<p>A command case may have associated an <em>undoer</em> which is similar to a command itself and is aimed to eventually do the &quot;reverse&quot; of that command case.
We need the <em>undoer</em> only if the storage we use lacks support for multiple stream transactions (like EventStoreDb).</p>
<pre><code class="language-FSharp">    type Undoer&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; = 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;
</code></pre>
<p>When we use storages like <em>in memory</em> or <em>Postgres</em>, we don't need to define any <em>undoer</em> for our commands, because those storages support multiple stream transactions.
Otherwise, we need to define an <em>undoer</em> if we know we are going to pass them to <em>runTwoCommands</em> on the command handler.</p>
<p>The abstract definition of a command is:</p>
<pre><code class="language-FSharp">    type Command&lt;'A, 'E when 'E :&gt; Event&lt;'A&gt;&gt; =
        abstract member Execute: 'A -&gt; Result&lt;List&lt;'E&gt;, string&gt;
        abstract member Undoer: Option&lt;'A -&gt; Result&lt;Undoer&lt;'A, 'E&gt;, string&gt;&gt;
</code></pre>
<p>The &quot;command undoer&quot; returns a function that, applied to the state, must return the actual <em>undoer</em>.</p>
<p>So the undoers work in two shots: one to build a context for the eventual future undo, and one to actually... <em>do</em> the <em>undo</em>. </p>
<p><strong>Example of &quot;undoer&quot;</strong> :</p>
<p>The <em>RemoveTag</em> command returns a list of TagRemoved events. We know that when those events are processed the result is the new cluster state without the tags.
However, we may want to roll back the effect of those events by adding events that reverse their effect.</p>
<p>This applies to a transaction context: you need to be able to re-add the tag to the state. For this reason, you need to build a context <em>before</em> the removal so that the tag to be eventually readded is still available.</p>
<p>From the code with some comments:</p>
<pre><code class="language-Fsharp">    member this.Undoer = 
        match this with
        | RemoveTag g -&gt; 
            // block to be executed before the actual command removing tag 
            // is executed. It will return another function with the context needed (the tag itself)
            (fun (x: TagsCluster) -&gt;
                result {
                    let! tag = x.GetTag g
                    let result =

                        // block to be executed after the actual command removing tag is executed.  
                        // It will return the list of events to be applied to the cluster state to compensate the effect of the command. 
                        // Note that the tag is the context needed to readd the tag to the  state.

                        fun (x': TagsCluster) -&gt;
                            x'.AddTag tag 
                            |&gt; Result.map (fun _ -&gt; [TagAdded tag])
                    return result
                }
            )
            |&gt; Some
        | AddTag t -&gt;
            // this case is simple than the previous because there is no need to retrieve anything from the context before the command is executed. 
            // The context is the tag itself (particularly its id), that can't be lost during the transaction.
            (fun (_: TagsCluster) -&gt;
                fun (x': TagsCluster) -&gt;
                    x'.RemoveTag t.Id 
                    |&gt; Result.map (fun _ -&gt; [TagAdded t])
                |&gt; Ok
            )
            |&gt; Some

</code></pre>
<p>Source code: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/clusters/Todos/Commands.fs">Commands.fs</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-service-layer"><a class="header" href="#application-service-layer">Application service layer</a></h1>
<p>An application service layer provides services that use Repository and Storage to get the state and/or send commands to one or more clusters (eventually in an atomic/transactional way with potential performance issues) and store the related events.</p>
<p>Here is one of the simplest examples of an entry for a service involving a single cluster, by building and running an AddTag command.</p>
<pre><code class="language-FSharp">    member this.addTag tag =
        result {
            let! _ =
                tag
                |&gt; AddTag
                |&gt; (runCommand&lt;TagsCluster, TagEvent&gt; storage)
            return ()
        }
</code></pre>
<p>The service layer sends commands to the Command Handler so that this one can run it producing and storing the related events.</p>
<p>Here is an example of using an explicit lock for consistency in an operation involving two clusters (we check that the tag is valid before adding the todo and inhibit write access to tags while the todo is being added).</p>
<pre><code class="language-FSharp">    member this.addTodo todo =
        lock TagsCluster.LockObj &lt;| fun () -&gt;
            result {
                let! (_, tagState) = getState&lt;TagsCluster, TagEvent&gt;(storage)
                let tagIds = tagState.GetTags() |&gt;&gt; (fun x -&gt; x.Id)

                let! tagIdIsValid =    
                    (todo.TagIds.IsEmpty ||
                    todo.TagIds |&gt; List.forall (fun x -&gt; (tagIds |&gt; List.contains x)))
                    |&gt; boolToResult &quot;A tag reference contained is in the todo is related to a tag that does not exist&quot;

                return! 
                    todo
                    |&gt; TodoCommand.AddTodo
                    |&gt; (runCommand&lt;TodosCluster, TodoEvent&gt; storage)
            }
</code></pre>
<p>The todo can be added only if it contains valid tag references.</p>
<p>I may just have the same effect by passing the entire block to a mailboxprocessor:</p>
<pre><code class="language-FSharp">        member this.AddTodo todo =
            let f = fun () -&gt;
                ResultCE.result {
                    let! (_, tagState) = storage |&gt; getState&lt;TagsCluster, TagEvent&gt; 
                    let tagIds = tagState.GetTags() |&gt;&gt; (fun x -&gt; x.Id)

                    let! tagIdIsValid =    
                        (todo.TagIds.IsEmpty ||
                        todo.TagIds |&gt; List.forall (fun x -&gt; (tagIds |&gt; List.contains x)))
                        |&gt; boolToResult &quot;A tag reference contained in the todo is related to a tag that does not exist&quot;

                    let! _ =
                        todo
                        |&gt; TodoCommand.AddTodo
                        |&gt; runCommand&lt;TodosCluster, TodoEvent&gt; storage
                    let _ = 
                        storage
                        |&gt; mkSnapshotIfInterval&lt;TodosCluster, TodoEvent&gt;
                return ()
            }
            async {
                return processor.PostAndReply (fun rc -&gt; f, rc)
            }
            |&gt; Async.RunSynchronously
</code></pre>
<h2 id="running-two-commands-to-different-clusters"><a class="header" href="#running-two-commands-to-different-clusters">Running two commands to different clusters</a></h2>
<p>This code removes the tag with any reference to it. It builds two commands and makes the repository process them at the same time.
This code removes a tag and any reference to it.</p>
<pre><code class="language-FSharp">    member this.removeTag id =
        ResultCE.result {
            let removeTag = TagCommand.RemoveTag id
            let removeTagRef = TodoCommand.RemoveTagRef id
            return! runTwoCommands&lt;TagsCluster, TodosCluster, TagEvent, TodoEvent&gt; storage removeTag removeTagRef
        }
</code></pre>
<p>The <em>runTwoCommands</em> uses the undoer of the storage requires it.</p>
<p>Source: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Sample/App.fs">App.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-handler"><a class="header" href="#command-handler">Command Handler</a></h1>
<p>The Command Handler has the responsibility of:</p>
<ul>
<li>getting the state</li>
<li>trying to run commands passed, and eventually storing the related events.</li>
<li>making periodic snapshots, according to the SnapshotsInterval.</li>
</ul>
<p>There are two different command handler implementations:</p>
<p>Code in <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/CommandHandler.fs">CommandHandler.fs</a>
<a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Lib/Core.fs">Core.fs</a></p>
<p>There is also an experimental repository based on a publish/subscribe storage model (Eventstoredb).
See <em>lightrepository</em></p>
<p><a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/LightCommandHandler.fs">LightCommandHandler.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>A storage stores and retrieves events and snapshots related to each single cluster.</p>
<p>I created also a &quot;lightweight&quot; version of the storage interface assuming that there are storage types where you will not need all the full storage interface.</p>
<p>Reset must be used only for development and testing, and cannot be used in production. See Conf.fs.</p>
<p>An example of a storage implementation in Postgres: <a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/DbStorage.fs">DbStorage.fs</a></p>
<h1 id="eventstorebridge"><a class="header" href="#eventstorebridge">EventStoreBridge:</a></h1>
<p>The alternative storage is the EventStoreBridge, which is a bridge to the EventStore database.
It is still experimental.
<a href="https://github.com/tonyx/Sharpino/blob/main/Sharpino.Lib/EventStoreStorage.fs">EventStoreBridge.fs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refactoring-strategy"><a class="header" href="#refactoring-strategy">Refactoring strategy</a></h1>
<p>By cluster refactoring, I mean when we just move models (collections of entities) among clusters.</p>
<p>Here I am showing a strategy for refactoring in terms of:</p>
<ul>
<li>moving the model's ownership between clusters, </li>
<li>introducing new clusters </li>
<li>upgrading old clusters.</li>
<li>dropping clusters.</li>
</ul>
<p>The problem arises because it looks overcomplicated d to make upfront decisions about clusters.</p>
<p>It looks to me more convenient to have a few clusters, for instance in a development and prototyping stage because this will simplify testing, prototyping, and building the application service layer.
Consider the extreme when we have everything in a single cluster. It would mean that the application service layer will be able to handle all the models with few lines of code (just building single command for the repository)</p>
<p>However, at a later stage, proper refactoring is probably needed for performance reasons.</p>
<p>Refactoring leaves the application service layer behavior unchanged.</p>
<p>The steps that may be followed are:</p>
<ul>
<li>defining new clusters and eventually creating upgraded versions of current clusters</li>
<li>moving entities ownership</li>
<li>creating an upgraded version of the application service layer using the new versions</li>
<li>applying the equivalent tests of the previous service layer to the new one.</li>
</ul>
<p>About this latest point, a parametric testing strategy is also possible.</p>
<p>Here is an example of a list of tuples of multiple application version configurations with migration functions.</p>
<pre><code class="language-FSharp">let allVersions =
    [
        (applicationPostgresStorage,        applicationPostgresStorage,       fun () -&gt; () |&gt; Result.Ok)
        (applicationShadowPostgresStorage,  applicationShadowPostgresStorage, fun () -&gt; () |&gt; Result.Ok)
        (applicationPostgresStorage,        applicationShadowPostgresStorage, applicationPostgresStorage._migrator.Value)

        (applicationMemoryStorage,          applicationMemoryStorage,         fun () -&gt; () |&gt; Result.Ok)
        (applicationShadowMemoryStorage,    applicationShadowMemoryStorage,   fun () -&gt; () |&gt; Result.Ok)
        (applicationMemoryStorage,          applicationShadowMemoryStorage,   applicationMemoryStorage._migrator.Value)
    ]
</code></pre>
<p>There are specific attributes to distinguish current and &quot;upgrading&quot; versions of elements of the application. </p>
<p>A migration function is needed to extract data from the current version and store it in the upgraded version.</p>
<p>Code here: <a href="https://github.com/tonyx/Micro_ES_FSharp_Lib/blob/main/Sharpino.Sample.Test/MultiVersionsTests.fs">MultiVersionsTests.fs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>As I mentioned in the previous chapter we may have different versions of the same application based on different clusters.</p>
<p>We may want to test all of them and also we may want to test the migration function from one version to another in those tests.
A structure of a parametric test that considers various possible combinations of application versions and migration functions is the following:</p>
<pre><code class="language-FSharp">
        multipleTestCase &quot;test something &quot; versions &lt;| fun (ap, apUpgd, migrator)  -&gt;
            let _ = ap._reset()

            // test something on ap, which is the &quot;initial version&quot; 
            // of the application
            .....

            // then migrate from &quot;ap&quot; version to apUpgd version 
            // using its migrator function

            let migrated = migrator()
            Expect.isOk migrated &quot;should be ok&quot;

            // test something on apUpgd, which is the &quot;upgraded version&quot; of the application

</code></pre>
<p>In some cases, you just want to run your tests fast and you don't want to test everything against all the possible combinations of application versions.</p>
<p>Then you may just skip some of the versions set up in the &quot;version&quot; triples <strong>(initversion, endversion, migrator)</strong> by commenting out temporarily the ones you don't want to spend time to test at the moment:</p>
<pre><code class="language-FSharp">let allVersions =
    [

        // (AppVersions.currentPostgresApp,        AppVersions.currentPostgresApp,     fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.upgradedPostgresApp,       AppVersions.upgradedPostgresApp,    fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.currentPostgresApp,        AppVersions.upgradedPostgresApp,    AppVersions.currentPostgresApp._migrator.Value)

        (AppVersions.currentMemoryApp,          AppVersions.currentMemoryApp,       fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.upgradedMemoryApp,         AppVersions.upgradedMemoryApp,      fun () -&gt; () |&gt; Result.Ok)
        // (AppVersions.currentMemoryApp,          AppVersions.upgradedMemoryApp,      AppVersions.currentMemoryApp._migrator.Value)

        // (AppVersions.evSApp,                    AppVersions.evSApp,                 fun () -&gt; () |&gt; Result.Ok)
    ]

</code></pre>
<p>The above code enables only the tests of the current version of the app that uses the in-memory storage.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
